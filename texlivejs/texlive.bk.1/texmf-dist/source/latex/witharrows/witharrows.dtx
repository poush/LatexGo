% \iffalse meta-comment
%
% Copyright (C) 2017-2019 by F. Pantigny
% -----------------------------------
%
% This file may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3
% of this license or (at your option) any later version.
% The latest version of this license is in:
%
% http://www.latex-project.org/lppl.txt
%
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
%
% \fi
% \iffalse
\def\myfileversion{1.15}
\def\myfiledate{2019/02/20}
%
%
%<*batchfile>
\begingroup
\input l3docstrip.tex
\keepsilent
\usedir{tex/latex/witharrows}
\preamble

Copyright (C) 2017-2019 by F. Pantigny
-----------------------------------

This file may be distributed and/or modified under the
conditions of the LaTeX Project Public License, either version 1.3
of this license or (at your option) any later version.
The latest version of this license is in:

http://www.latex-project.org/lppl.txt

and version 1.3 or later is part of all distributions of LaTeX
version 2005/12/01 or later.

\endpreamble
\askforoverwritefalse
\endgroup
%</batchfile>
%
%<@@=witharrows>
%<*driver>
\documentclass[dvipsnames]{l3doc}% dvipsnames is for xcolor (loaded by Tikz, loaded by witharrows)
\usepackage{xltxtra}
\usepackage{geometry}
\geometry{left=2.8cm,right=2.8cm,top=2.5cm,bottom=2.5cm,papersize={21cm,29.7cm}}
\usepackage[footnotehyper]{witharrows}
\usetikzlibrary{calc}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage[only,llbracket,rrbracket]{stmaryrd}
\usepackage{varwidth}
\NewDocumentEnvironment {scope} {} {} {}
\def\interitem{\vskip 7mm plus 2 mm minus 3mm}          
\def\emphase{\bgroup\color{RoyalPurple}\let\next=}
\fvset{commandchars=\~\#\@,formatcom={\color{gray}}}
\DeclareMathOperator{\re}{Re}
\parindent 0pt
\DisableCrossrefs
\begin{document}
\DocInput{witharrows.dtx}
\end{document}
%</driver>
% \fi 
% \VerbatimFootnotes
% \title{The package \pkg{witharrows}\thanks{This document corresponds to the version~\myfileversion\space of \pkg{witharrows},
% at the date of~\myfiledate.}} \author{F. Pantigny \\ \texttt{fpantigny@wanadoo.fr}}
%
% \maketitle
%
% \begin{abstract}
% The LaTeX package \pkg{witharrows} provides environments |{WithArrows}| and
% |{DispWithArrows}| similar to the environments |{aligned}| and |{align}| of
% \pkg{amsmath} but with the possibility to draw arrows on the right side of the
% alignment. These arrows are usually used to give explanations concerning the
% mathematical calculus presented.
% \end{abstract}
%
%
% \vskip1cm 
% This package can be used with |xelatex|, |lualatex|, |pdflatex| but also by
% the classical workflow |latex|-|dvips|-|ps2pdf| (or Adobe Distiller). Two
% compilations may be necessary. This package requires the packages \pkg{expl3},
% \pkg{xparse} and \pkg{tikz}. The Tikz libraries \pkg{arrows.meta} and
% \pkg{bending} are also required.
%
% \bigskip
% This package provides an environment |{WithArrows}| to construct alignments of
% equations with arrows for the explanations on the right side:
% 
% \begin{Verbatim}
% $\begin{WithArrows}
% A & = (a+1)^2 ~emphase#\Arrow{we expand}@ \\
%   & = a^2 + 2a + 1  
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}
% A & = (a+1)^2 \Arrow{we expand} \\
%   & = a^2 + 2a + 1  
% \end{WithArrows}$
%
%
%
% \medskip
% The arrow has been drawn with the command |\Arrow| on the row from which it
% starts. The command |\Arrow| must be used in the second column (the best way
% is to put it at the end of the second cell of the row as in the previous
% example).
%
% \medskip
% The environment |{WithArrows}| bears similarities with the environment
% |{aligned}| of |amsmath| (and |mathtools|). The extension \pkg{witharrows}
% also provides an environment |{DispWithArrows}| which is similar to the
% environment |{align}| of |amsmath|: cf. p. \pageref{DispWithArrows}.
% 
%
% \section{Options for the shape of the arrows}
%
% The command |\Arrow| has several options. These options can be put between
% square brackets, before, or after the mandatory argument.
%
% The option |jump| gives the number\footnote{It's not possible to give a
% non-positive value to |jump|. See below (p.~\pageref{Backwards}) the way to
% draw an arrow which goes backwards.} of rows the arrow must jump (the default
% value is, of course,~$1$).
%
% 
% \begin{Verbatim}
% $\begin{WithArrows}
% A & = \bigl((a+b)+1\bigr)^2 \Arrow[~emphase#jump=2@]{we expand} \\
%   & = (a+b)^2 +  2(a+b) +1 \\
%   & = a^2 + 2ab + b^2 + 2a + 2b +1 
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}
% A & = \bigl((a+b)+1\bigr)^2 \Arrow[jump=1+1]{we expand} \\
%   & = (a+b)^2 + 2(a+b) +1 \\
%   & = a^2 + 2ab + b^2 + 2a + 2b +1 
% \end{WithArrows}$
%
% \interitem
% It's possible to put several arrows which start from the same row.
% \begin{Verbatim}
% $\begin{WithArrows}
% A & = \bigl((a+b)+1\bigr)^2 ~emphase#\Arrow{}\Arrow{}[jump=2]@ \\
%   & = (a+b)^2 + 2(a+b) +1 \\
%   & = a^2 + 2ab + b^2 + 2a + 2b +1 
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}
% A & = \bigl((a+b)+1\bigr)^2 \Arrow{}\Arrow{}[jump=2] \\
%   & = (a+b)^2 + 2(a+b) +1 \\
%   & = a^2 + 2ab + b^2 + 2a + 2b +1 
% \end{WithArrows}$
%
% \interitem
% The option |xoffset| shifts the arrows to the right (we usually don't want the
% arrows to be stucked on the text). The default value of |xoffset| is $3$~mm.
% \begin{Verbatim}
% $\begin{WithArrows}
% A & = \bigl((a+b)+1\bigr)^2 
% \Arrow[~emphase#xoffset=1cm@]{with \texttt{xoffset=1cm}} \\
%   & = (a+b)^2 + 2(a+b) +1 
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}
% A & = \bigl((a+b)+1\bigr)^2 
% \Arrow[xoffset=1cm]{with \texttt{xoffset=1cm}} \\
%   & = (a+b)^2 + 2(a+b) +1 
% \end{WithArrows}$
%
%
% \interitem 
% The arrows are drawn with Tikz. That's why the command |\Arrow| has an option
% |tikz| which can be used to give to the arrow (in fact, the command |\path| of
% Tikz) the options proposed by Tikz for such an arrow. The following example
% gives an thick arrow.
% \begin{Verbatim}
% $\begin{WithArrows}
% A & = (a+1)^2 \Arrow[~emphase#tikz=thick@]{we expand} \\
%   & = a^2 + 2a + 1 
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}
% A & = (a+1)^2 \Arrow[tikz=thick]{we expand} \\
%   & = a^2 + 2a + 1 
% \end{WithArrows}$
%
% \interitem
% It's also possible to change the arrowheads. For example, we can draw an arrow
% which goes backwards with the Tikz option~|<-|.
% \label{Backwards} 
%
% \begin{Verbatim}
% $\begin{WithArrows}
% A & = (a+1)^2 \Arrow~emphase#[tikz=<-]@{we factorize} \\
%   & = a^2 + 2a + 1 
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}
% A & = (a+1)^2 \Arrow[tikz=<-]{we factorize} \\
%   & = a^2 + 2a + 1 
% \end{WithArrows}$
%
% \interitem
% It's also possible to suppress both tips of the arrow with the Tikz option
% |-|.
% \begin{Verbatim}
% $\begin{WithArrows}
% A & = (a+1)^2 \Arrow[~emphase#tikz=-@]{very classical} \\
%   & = a^2 + 2a + 1 
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}
% A & = (a+1)^2 \Arrow[tikz=-]{very classical} \\
%   & = a^2 + 2a + 1 
% \end{WithArrows}$
%
% \interitem
% In order to have straight arrows instead of curved ones, we must use the Tikz
% option ``|bend left = 0|''.
% \begin{Verbatim}
% $\begin{WithArrows}
% A & = (a+1)^2 \Arrow~emphase#[tikz={bend left=0}]@{we expand} \\
%   & = a^2 + 2a + 1 
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}
% A & = (a+1)^2 \Arrow[tikz={bend left=0}]{we expand} \\
%   & = a^2 + 2a + 1 
% \end{WithArrows}$
%
% \smallskip 
% In fact, it's possible to change more drastically the shape or the arrows with
% the option |TikzCode| presented p.~\pageref{TikzCode}.
%
% \interitem
% It's possible to use the Tikz option ``|text width|'' to control the width of
% the text associated to the arrow.\footnote{It's possible to avoid the
% hyphenations of the words with the option ``|align = flush left|'' of Tikz.}
% %
% \begin{Verbatim}
% $\begin{WithArrows}
% A & = \bigl((a+b)+1\bigr)^2 
% \Arrow[jump=2,~emphase#tikz={text width=5.3cm}@]{We have done...} \\
%   & = (a+b)^2 + 2(a+b) +1 \\
%   & = a^2 + 2ab + b^2 + 2a + 2b +1 
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}
% A & = \bigl((a+b)+1\bigr)^2 
% \Arrow[jump=2,tikz={text width=5.3cm}]{We have done a two-stages expansion but
% it would have been clever
% to expand with the multinomial theorem.} \\
% & = (a+b)^2 + 2(a+b) +1 \\
% & = a^2 + 2ab + b^2 + 2a + 2b +1
% \end{WithArrows}$
%
%
% \bigskip
% In the environments |{DispWithArrows}| and |{DispWithArrows*}|, there is an
% option |wrap-lines|. With this option, the lines of the labels are
% automatically wrapped on the right: see p.~\pageref{wrap-lines}.
% 
% \interitem
% If we want to change the font of the text associated to the arrow, we can, of
% course, put a command like |\bfseries|, |\large| or |\sffamily| at the
% beginning of the text. But, by default, the texts are composed with a
% combination of |\small| and |\itshape|. When adding |\bfseries| at the
% beginning of the text, we won't suppress the |\small| and the |\itshape| and
% we will consequently have a text in a bold, italic and small font.
% %
% \begin{Verbatim}
% $\begin{WithArrows}
% A & = (a+1)^2 \Arrow{~emphase#\bfseries@ we expand} \\
%   & = a^2 + 2a + 1 
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}
% A & = (a+1)^2 \Arrow{\bfseries we expand} \\
%   & = a^2 + 2a + 1 
% \end{WithArrows}$
%
% \interitem 
% It's possible to put commands |\\| in the text to force new lines\footnote{By
% default, this is not possible in a Tikz node. However, in \pkg{witharrows},
% the nodes are created with the option |align=left|, and, thus, it becomes
% possible.}. However, if we put a |\\| , a command of font placed in the
% beginning of the text will have effect only until the first command |\\| (like
% in an environment |{tabular}|). That's why Tikz gives an option |font| to
% modify the font of the whole text. Nevertheless, if we use the option
% |tikz={font={\bfseries}}|, the default specification of |\small| and
% |\itshape| will be overwritten.
% %
% \begin{Verbatim}
% $\begin{WithArrows}
% A & = (a+1)^2 \Arrow[~emphase#tikz={font={\bfseries}}@]{we expand} \\
%   & = a^2 + 2a + 1 
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}
% A & = (a+1)^2 \Arrow[tikz={font={\bfseries}}]{we expand} \\
%   & = a^2 + 2a + 1 
% \end{WithArrows}$
%
% \medskip
% If we want exactly the same result as previously, we have to give to the
% option |font| the value |{\itshape\small\bfseries}|.
%
%
% \interitem 
% Almost all the options can be given directly between square brackets to the
% environment |{WithArrows}|. \textbf{There must be no space before the opening
% bracket (|[|) of the options of the environment.} The options apply to all the
% arrows of the environment.\footnote{They also apply to the nested environments
% |{WithArrows}| (with the logical exceptions of |interline|, |CodeBefore| and
% |CodeAfter|).}
% %
% \begin{Verbatim}
% $\begin{WithArrows}[~emphase#tikz=blue@]
% A & = \bigl((a+b)+1\bigr)^2 \Arrow{first expansion.} \\
%   & = (a+b)^2 + 2(a+b) +1 \Arrow{second expansion.} \\
%   & = a^2 + 2ab + b^2 + 2a + 2b +1 
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}[tikz=blue]
% A & = \bigl((a+b)+1\bigr)^2 \Arrow{first expansion.} \\
%   & = (a+b)^2 + 2(a+b) +1 \Arrow{second expansion.} \\
%   & = a^2 + 2ab + b^2 + 2a + 2b +1 
% \end{WithArrows}$
%
%
% \interitem
% The environment |{WithArrows}| has an option |displaystyle|. With this option,
% all the elements are composed in |\displaystyle| (like in an environment
% |{aligned}| of \pkg{amsmath}).
%
% \medskip
% Without the option |displaystyle|:
% %
% \begin{Verbatim}
% $\begin{WithArrows}
% \int_0^1 (x+1)^2 dx 
% & = \int_0^1 (x^2+2x+1) dx
% \Arrow{linearity of integration}     \\
% & = \int_0^1 x^2 dx + 2 \int_0^1 x dx + \int_0^1 dx \\
% & = \frac13 + 2\frac12 + 1 \\
% & = \frac73
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}
% \int_0^1 (x+1)^2 dx 
% & = \int_0^1 (x^2+2x+1) dx
% \Arrow{linearity of integration}     \\
% & = \int_0^1 x^2 dx + 2 \int_0^1 x dx + \int_0^1 dx \\
% & = \frac13 + 2\frac12 + 1 \\
% & = \frac73
% \end{WithArrows}$
%
%
% \medskip
% The same example with the option |displaystyle|:\par\nobreak
%
% $\begin{WithArrows}[displaystyle]
% \int_0^1 (x+1)^2 dx 
% & = \int_0^1 (x^2+2x+1) dx
% \Arrow{linearity of integration}     \\
% & = \int_0^1 x^2 dx + 2 \int_0^1 x dx + \int_0^1 dx \\
% & = \frac13 + 2\frac12 + 1 \\
% & = \frac73
% \end{WithArrows}$
%
%
%
% \interitem 
% Almost all the options can also be set at the document level with the command
% |\WithArrowsOptions|. In this case, the scope of the declarations is the
% current TeX group (these declarations are ``semi-global''). For example, if we
% want all the environments |{WithArrows}| composed in |\displaystyle| with blue
% arrows, we can write
% |\WithArrowsOptions{displaystyle,tikz=blue}|.\footnote{It's also possible to
% configure \pkg{witharrows} by modifying the Tikz style |WithArrows/arrow|
% which is the style used by \pkg{witharrows} when drawing an arrow. For
% example, to have the labels in blue with roman (upright) types, one can use
% the following instruction: 
% |\tikzset{WithArrows/arrow/.append style = {blue,font = {}}}|.}
% 
% \begin{Verbatim}
% ~emphase#\WithArrowsOptions{displaystyle,tikz=blue}@
% $\begin{WithArrows}
% \sum_{i=1}^n (x_i+1)^2 
% & = \sum_{i=1}^n (x_i^2+2x_i+1) \Arrow{by linearity}\\
% & = \sum_{i=1}^n x_i^2 + 2\sum_{i=1}^nx_i+ n
% \end{WithArrows}$
% \end{Verbatim}
%
% \begin{scope}
% \WithArrowsOptions{displaystyle,tikz=blue}
% $\begin{WithArrows}
% \sum_{i=1}^n (x_i+1)^2 
% & = \sum_{i=1}^n (x_i^2+2x_i+1) \Arrow{by linearity}\\
% & = \sum_{i=1}^n x_i^2 + 2\sum_{i=1}^nx_i+ n
% \end{WithArrows}$
% \end{scope}
%
%
% \interitem
% The command |\Arrow| is recognized only in the environments |{WithArrows}|. If
% we have a command |\Arrow| previously defined, it's possible to go on using it
% outside the environments |{WithArrows}|.
%
% However, a previouly defined command |\Arrow| may still be useful in an
% environment |{WithArrows}|. If we want to use it in such an environment, it's
% possible to change the name of the command |\Arrow| of the package
% \pkg{witharrows}: there is an option |CommandName| for this purpose. The new
% name of the command must be given to the option \emph{without} the leading
% backslash.
% %
% \begin{Verbatim}
% \NewDocumentCommand {\Arrow} {} {\longmapsto}
% $\begin{WithArrows}[~emphase#CommandName=Explanation@]
% f & = \bigl(x \Arrow (x+1)^2\bigr)
% ~emphase#\Explanation{we work directly on fonctions}@\\
% & = \bigl(x \Arrow x^2+2x+1\bigr)
% \end{WithArrows}$
% \end{Verbatim}
% %
% \begin{scope}
% \NewDocumentCommand {\Arrow} {} {\longmapsto}
% $\begin{WithArrows}[CommandName=Explanation]
% f & = \bigl(x \Arrow (x+1)^2\bigr)
% \Explanation{we work directly on fonctions}\\
% & = \bigl(x \Arrow x^2+2x+1\bigr)
% \end{WithArrows}$
% \end{scope}
%
%
% \interitem 
% The environment |{WithArrows}| gives also two options |CodeBefore| and
% |CodeAfter| for LaTeX code that will be executed at the beginning and at the
% end of the environment. These options are not designed to be hooks (they are
% available only at the environment level and they do not apply to the nested
% environments).
% %
% \begin{Verbatim}
% $\begin{WithArrows}[~emphase#CodeBefore = \color{blue}@]
% A & = (a+b)^2 \Arrow{we expand} \\
%   & = a^2 + 2ab + b^2 
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}[CodeBefore = \color{blue}]
% A & = (a+b)^2 \Arrow{we expand} \\
%   & = a^2 + 2ab + b^2 
% \end{WithArrows}$
% 
% \medskip 
% Special commands are available in |CodeAfter|: a command |\WithArrowsNbLines|
% which gives the number of lines (=rows) of the current environment (this is a
% command and not a counter), a special form of the command |\Arrow| and the
% command |\MultiArrow|: these commands are described in the section concerning
% the nested environments, p.~\pageref{NestedEnv}.
%
%
% \section{Precise positioning of the arrows}
%
%
% The environment |{WithArrows}| defines, during the composition of the array,
% two series of nodes materialized in red in the following example.\footnote{The
% option |show-nodes| can be used to materialize the nodes. The nodes are in
% fact Tikz nodes of shape ``rectangle'', but with zero width. An arrow between
% two nodes starts at the \emph{south} anchor of the first node and arrives at
% the \emph{north} anchor of the second node.}
%
% \smallskip
% $\begin{WithArrows}[displaystyle,show-nodes]
% I
% & = \int_{\frac{\pi}4}^0 \ln\Bigl(1+\tan\left(\tfrac{\pi}4-u\right)\Bigr)(-d u) \\
% & = \int_0^{\frac{\pi}4} \ln\Bigl(1+\tan\left(\tfrac{\pi}4-u\right)\Bigr)d u \\
% & = \int_0^{\frac{\pi}4}\ln\left(1+\frac{1-\tan u}{1+\tan u}\right)\, d u \\
% & =\int_0^{\frac{\pi}4}\ln\left(\frac{1+\tan u+1-\tan u}{1+\tan u}\right) d u \\
% & =\int_0^{\frac{\pi}4} \ln\left(\frac2{1+\tan u}\right)\, d u\\
% & =\int_0^{\frac{\pi}4}\bigl(\ln2-\ln(1+\tan u)\bigr)\, d u \\
% & =\frac{\pi}4\ln2-\int_0^{\frac{\pi}4}\ln(1+\tan u)\, d u  \\
% & =\frac{\pi}4\ln2-I 
% \end{WithArrows}$
%
% \bigskip
% The nodes of the left are at the end of each line of text. These nodes will be
% called \emph{left nodes}. The nodes of the right side are aligned vertically
% on the right side of the array. These nodes will be called \emph{right nodes}.
%
% By default, the arrows use the right nodes. We will say that they are in |rr|
% mode ($r$ for \emph{right}). These arrows are |vertical| (we will say that an
% arrow is \emph{vertical} when its two ends have the same abscissa).
%
%
% \smallskip
% However, it's possible to use the left nodes, or a combination of left and
% right nodes, with one of the options |lr|, |rl| and |ll| ($l$ for
% \emph{left}). Those arrows are, usually, not vertical.
%
%
% Therefore
% $\begin{WithArrows}[displaystyle]
% I
% & = \int_{\frac{\pi}4}^0 \ln\Bigl(1+\tan\left(\tfrac{\pi}4-u\right)\Bigr)(-d u) 
% \Arrow[lr]{This arrow uses the \texttt{lr} option.}\\
% & = \int_0^{\frac{\pi}4} \ln\Bigl(1+\tan\left(\tfrac{\pi}4-u\right)\Bigr)d u \\
% & = \int_0^{\frac{\pi}4}\ln\left(1+\frac{1-\tan u}{1+\tan u}\right)\, d u \\
% & =\int_0^{\frac{\pi}4}\ln\left(\frac{1+\tan u+1-\tan u}{1+\tan u}\right) d u 
% \Arrow[ll,jump=2,tikz={text width = 5cm}]{This arrow uses a \texttt{ll} option and a \texttt{jump} equal to $2$}\\
% & =\int_0^{\frac{\pi}4} \ln\left(\frac2{1+\tan u}\right)\, d u\\
% & =\int_0^{\frac{\pi}4}\bigl(\ln2-\ln(1+\tan u)\bigr)\, d u \\
% & =\frac{\pi}4\ln2-\int_0^{\frac{\pi}4}\ln(1+\tan u)\, d u  \\
% & =\frac{\pi}4\ln2-I 
% \end{WithArrows}$
%
%
%
% \interitem
% There is also an option called \texttt{i} ($i$ for \emph{intermediate}). With
% this option, the arrow is vertical and at the leftmost position.
%
% \begin{Verbatim}
% $\begin{WithArrows}
% (a+b)(a+ib)(a-b)(a-ib) 
% & = (a+b)(a-b)\cdot(a+ib)(a-ib) \\
% & = (a^2-b^2)(a^2+b^2) \Arrow~emphase#[i]@{because $(x-y)(x+y)=x^2-y^2$}\\
% & = a^4-b^4 
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}
% (a+b)(a+ib)(a-b)(a-ib) 
% & = (a+b)(a-b)\cdot(a+ib)(a-ib) \\
% & = (a^2-b^2)(a^2+b^2) \Arrow[i]{because $(x-y)(x+y)=x^2-y^2$}\\
% & = a^4-b^4 
% \end{WithArrows}$
%
%
% \interitem 
% The environment |{WithArrows}| gives also a |group| option. With this option,
% \emph{all} the arrows of the environment are grouped on a same vertical line
% and at a leftmost position.
% %
% \begin{Verbatim}[formatcom=\small\color{gray}]
% $\begin{WithArrows}[~emphase#displaystyle,group@]
% 2xy'-3y=\sqrt x
% & \Longleftrightarrow 2x(K'y_0+Ky_0')-3Ky_0 = \sqrt x \\
% & \Longleftrightarrow 2xK'y_0 + K(2xy_0'-3y_0) = \sqrt x \\
% & \Longleftrightarrow 2x K'y_0 = \sqrt x \Arrow{...}\\
% ...
% \end{WithArrows}$
% \end{Verbatim}
%
%
% $\begin{WithArrows}[displaystyle,group]
% 2xy'-3y=\sqrt x
% & \Longleftrightarrow 2x(K'y_0+Ky_0')-3Ky_0 = \sqrt x \\
% & \Longleftrightarrow 2xK'y_0 + K(2xy_0'-3y_0) = \sqrt x \\
% & \Longleftrightarrow 2x K'y_0 = \sqrt x \Arrow{we replace $y_0$ by its value}\\
% & \Longleftrightarrow 2xK'x^{\frac32} = x^{\frac12} \Arrow{simplification of the $x$}\\
% & \Longleftrightarrow K' = \tfrac1{2x^2} \Arrow{antiderivation}\\
% & \Longleftrightarrow K = -\tfrac1{2x} 
% \end{WithArrows}$
%
%
% \bigskip
% The environment |{WithArrows}| gives also a |groups| option (with a \emph{s}
% in the name). With this option, the arrows are divided into several
% ``groups''. Each group is a set of connected\footnote{More precisely: for each
% arrow $a$, we note $i(a)$ the number of its initial row and $f(a)$ the number
% of its final row; for two arrows $a$ and $b$, we say that $a \sim b$ when
% $\llbracket i(a),f(a)\rrbracket \cap \llbracket i(b),f(b)\rrbracket \neq
% \varnothing$; the groups are the equivalence classes of the transitive closure
% of $\sim$.} arrows. All the arrows of a given group are grouped on a same
% vertical line and at a leftmost position.
%
% \bigskip
% $\begin{WithArrows}[groups]
% A & = B \Arrow{one} \\
%   & = C+D \Arrow{two} \\
%   & = D' \\
%   & = E+F+G+H+I \\
%   & = K + L + M \Arrow{three}\\
%   & = N \Arrow{four}\\
%   & = O
% \end{WithArrows}$
%
% \bigskip 
% In an environment which uses the option |group| or the option |groups|, it's
% still possible to give an option of position (|ll|, |lr|, |rl|, |rr| or |i|)
% to an individual arrow. Such arrow will be drawn irrespective of the groups.
% It's also possible to start a new group by applying the option |new-group| to
% an given arrow.
% 
% \bigskip
% If desired, the option |group| or the option |groups| can be given to the
% command |\WithArrowsOptions| so that it will become the default value. In this
% case, it's still possible to come back to the default behaviour for a given
% environment |{WithArrows}| with the option |rr|: |\begin{WithArrows}[rr]|
%
%
% \vspace{1cm}
% In the following example, we have used the option |group| for the environment
% and the option |rr| for the last arrow (that's why the last arrow is not
% aligned with the others).
%
% $\begin{WithArrows}[interline=1mm,group]
% \sum\limits_{k=0}^n\frac{\cos kx}{\cos^k x}
% & = \sum\limits_{k=0}^n \frac{\Re (e^{ikx})}{(\cos x)^k} 
% \Arrow{$(\cos x)^k$ is real} \\
% & = \sum\limits_{k=0}^n \Re\left(\frac{e^{ikx}}{(\cos x)^k}\right)
% \Arrow{$\Re(z+z')=\Re(z)+\Re(z')$}\\
% & = \Re \left(\sum\limits_{k=0}^n \left(\frac{e^{ix}}{\cos x}\right)^k\right)
% \Arrow{sum of terms of a geometric progression} \\
% & = \Re \left(\frac{1-\left(\frac{e^{ix}}{\cos x}\right)^{n+1}}{1-\frac{e^{ix}}{\cos x}} \right)
% \Arrow{algebraic calculation} \\
% & = \Re \left(\frac{1-\frac{e^{i(n+1)x}}{\cos^{n+1}x}}{1-\frac{e^{ix}}{\cos x}}\right)
% \Arrow{reduction to common denominator} \\
% & = \Re \left(\frac{\frac{\cos^{n+1}x-e^{i(n+1)x}}{\cos^{n+1}x}}{\frac{\cos x-e^{ix}}{\cos x}}\right)
% \Arrow{$\Re(kz) = k\cdot\Re(z)$ if $k$ is real} \\
% & = \frac1{\cos^n x}\Re \left(\frac{\cos^{n+1}x-e^{i(n+1)x}}{\cos x-e^{ix}}\right)
% \Arrow[rr]{algebraic form of the complexes} \\
% & =\frac1{\cos^n x}\Re\left(\frac{\cos^{n+1}x-(\cos(n+1)x+i\sin(n+1)x)}{\cos x-(\cos x+i\sin x)}\right) \\
% & =\frac1{\cos^n x}\Re\left(\frac{(\cos^{n+1}x-\cos(n+1)x)-i\sin(n+1)x}{-i\sin x}\right) \\
% & = \frac1{\cos^nx}\cdot\frac{\sin(n+1)x}{\sin x}
% \end{WithArrows}$
%
% \interitem
%
% \section{The options ``up'' and ``down'' for individual arrows}
%
% \label{up-and-down}
% At the local level, there are also two options for individuals arrows, called
% ``|up|'' and ``|down|''. The following example illustrates these types of
% arrows:
% 
% \begin{Verbatim}
% \(\begin{WithArrows}
% A & = B 
% \Arrow~emphase#[up]@{an arrow of type "up"} \\
%   & = C + C + C + C + C + C + C + C  \\
%   & = C + C + C + C + C + C + C + C  
% \Arrow~emphase#[down]@{an arrow of type "down"} \\
%   & = E + E 
% \end{WithArrows}\)
% \end{Verbatim}
% 
% \vspace{1cm}
% \(\begin{WithArrows}
% A & = B 
% \Arrow[up]{an arrow of type "up"} \\
%   & = C + C + C + C + C + C + C + C  \\
%   & = C + C + C + C + C + C + C + C  
% \Arrow[down]{an arrow of type "down"} \\
%   & = E + E 
% \end{WithArrows}\)
%
%
% \vspace{1cm}
% The options |up| and |down| require the package \pkg{varwidth} and the Tikz
% library \pkg{calc}. It they are not loaded, an error will be raised.
%
% \interitem
%
% \section{Comparison with the environment \{aligned\}}
%
% |{WithArrows}| bears similarities with the environment |{aligned}| of the
% extension \pkg{amsmath}. These are only similarities because |{WithArrows}|
% has not been written upon the environment |{aligned}|.\footnote{In fact, it's
% possible to use the package \pkg{witharrows} without the package
% \pkg{amsmath}.}
%
% \interitem
% As in the environments of \pkg{amsmath}, it's possible to change the spacing
% between two given rows with the option of the command |\\| of end of line
% (it's also possible to use |\\*| but it has exactly the same effect as |\\|
% since an environment |{WithArrows}| is always unbreakable). This option is
% designed to be used with positive values only.
% %
% \begin{Verbatim}
% $\begin{WithArrows}
% A & = (a+1)^2 \Arrow{we expand} ~emphase#\\[2ex]@
%   & = a^2 + 2a + 1 
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}
% A & = (a+1)^2 \Arrow{we expand} \\*[2ex]
% \noalign{\vspace{3mm}}
%   & = a^2 + 2a + 1 
% \end{WithArrows}$
%
%
% \interitem 
% In the environments of \pkg{amsmath} (or \pkg{mathtools}), the spacing between
% rows is fixed by a parameter called |\jot| (it's a dimension and not a skip).
% That's also the case for the environment |{WithArrows}|. An option |jot| has
% been given to the environment |{WithArrows}| in order to change the value of
% this parameter |\jot| for a given environment.\footnote{It's also possible to
% change |\jot| with the environment |{spreadlines}| of \pkg{mathtools}.}
% %
% \begin{Verbatim}
% $\begin{WithArrows}[displaystyle,~emphase#jot=2ex@]
% F & = \frac12G     \Arrow{we expand}\\
%   & = H + \frac12K \Arrow{we go on}\\
%   & = K 
% \end{WithArrows}$
% \end{Verbatim}
%
%
% $\begin{WithArrows}[displaystyle,jot=2ex]
% F & = \frac12G     \Arrow{we expand}\\
%   & = H + \frac12K \Arrow{we go on}\\
%   & = K 
% \end{WithArrows}$
%
%
% \bigskip
% However, this new value of |\jot| will also be used in other alignments
% included in the environment~|{WithArrows}|:
% %
% \begin{Verbatim}
% $\begin{WithArrows}[jot=2ex]
% \varphi(x,y) = 0  & \Leftrightarrow (x+y)^2 + (x+2y)^2 = 0 
% \Arrow{$x$ and $y$ are real}\\
% & \Leftrightarrow \left\{
% \begin{aligned}
% x+y & = 0 \\
% x+2y & = 0 
% \end{aligned}
% \right.
% \end{WithArrows}$
% \end{Verbatim}
%
%
% $\begin{WithArrows}[jot=2ex]
% \varphi(x,y) = 0  & \Leftrightarrow (x+y)^2 + (x+2y)^2 = 0 
% \Arrow{$x$ and $y$ are real}\\
% & \Leftrightarrow \left\{
% \begin{aligned}
% x+y & = 0 \\
% x+2y & = 0 
% \end{aligned}
% \right.
% \end{WithArrows}$
%
% \bigskip
% Maybe this doesn't correspond to the desired outcome. That's why an option
% |interline| is proposed. It's possible to use a skip (=glue) for this option.
% %
% \begin{Verbatim}
% $\begin{WithArrows}[~emphase#interline=2ex@]
% \varphi(x,y) = 0  & \Leftrightarrow (x+y)^2 + (x+2y)^2 = 0 
% \Arrow{$x$ and $y$ are real}\\
% & \Leftrightarrow \left\{
% \begin{aligned}
% x+y & = 0 \\
% x+2y & = 0 \\
% \end{aligned}
% \right.
% \end{WithArrows}$
% \end{Verbatim}
%
%
% $\begin{WithArrows}[interline=2ex]
% \varphi(x,y) = 0  & \Leftrightarrow (x+y)^2 + (x+2y)^2 = 0 
% \Arrow{$x$ and $y$ are real}\\
% & \Leftrightarrow \left\{
% \begin{aligned}
% x+y & = 0 \\
% x+2y & = 0 \\
% \end{aligned}
% \right.
% \end{WithArrows}$
%
%
% \interitem
% Like the environment |{aligned}|, |{WithArrows}| has an option of placement
% which can assume the values |t|, |c| or |b|. However, the default value is not
% |c| but |t|. If desired, it's possible to have the |c| value as the default
% with the command |\WithArrowsOptions{c}| at the beginning of the document.
% %
% \begin{Verbatim}
% So\enskip
% $\begin{WithArrows}
% A & = (a+1)^2 \Arrow{we expand} \\
%   & = a^2 + 2a + 1 
% \end{WithArrows}$
% \end{Verbatim}
%
% So\enskip 
% $\begin{WithArrows}
% A & = (a+1)^2 \Arrow{we expand} \\
%   & = a^2 + 2a + 1 
% \end{WithArrows}$
%
% \bigskip
% The value |c| may be useful, for example, if we want to add curly braces:
%
% \smallskip
% \begin{Verbatim}
% On pose\enskip $~emphase#\left\{@
% \begin{WithArrows}[~emphase#c@]
% f(x) & = 3x^3+2x^2-x+4 
% \Arrow[tikz=-]{both are polynoms}\\
% g(x) & = 5x^2-5x+6
% \end{WithArrows}
% ~emphase#\right.@$
% \end{Verbatim}
%
%
% On pose\enskip $\left\{
% \begin{WithArrows}[c]
% f(x) & = 3x^3+2x^2-x+4 
% \Arrow[tikz=-]{both are polynoms}\\
% g(x) & = 5x^2-5x+6
% \end{WithArrows}
% \right.$
%
%
% \interitem
% Unlike |{aligned}|, the environment |{WithArrows}| uses |\textstyle| by
% default.
%
% Once again, it's possible to change this behaviour with |\WithArrowsOptions|:
%
% \quad |\WithArrowsOptions{displaystyle}|.
%
%
% \smallskip
% The following example is composed with |{aligned}|:\par\nobreak
%
% \smallskip
% $\left\{
% \begin{aligned}
% \sum_{i=1}^n (x_i+1)^2  
% & = \sum_{i=1}^n (x_i^2 + 2x_i+1) \\
% & = \sum_{i=1}^n x_i^2 + 2 \sum_{i=1}^nx_i + n 
% \end{aligned}
% \right.$
%
%
% \medskip 
% The following is composed with |{WithArrows}[c,displaystyle]|. The results are
% strictly identical.\footnote{In versions of \pkg{amsmath} older than the
% 5~nov.~2016, a thin space was added on the left of an environment |{aligned}|.
% The new versions do not add this space and neither do
% |{WithArrows}|.}\par\nobreak
%
% \smallskip
% $\left\{
% \begin{WithArrows}[c,displaystyle]
% \sum_{i=1}^n (x_i+1)^2 
% & = \sum_{i=1}^n (x_i^2 + 2x_i+1) \\
% & = \sum_{i=1}^n x_i^2 + 2 \sum_{i=1}^nx_i + n 
% \end{WithArrows}
% \right.$
%
%
% \section{Arrows in nested environments}
%
% \label{NestedEnv}
%
% The environments |{WithArrows}| can be nested. In this case, the options given
% to the encompassing environment applies also to the inner ones (with logical
% exceptions for |interline|, |CodeBefore| and |CodeAfter|). The command |Arrow|
% can be used as usual in each environment |{WithArrows}|.
% 
% \begin{Verbatim}[formatcom=\small\color{gray}]
% $~emphase#\begin{WithArrows}@
% \varphi(x,y)=0
%   & \Leftrightarrow (x+2y)^2+(2x+4y)^2 = 0 \Arrow{the numbers are real}\\
%   & \Leftrightarrow
%   \left\{~emphase#\begin{WithArrows}@[c]
%   x+2y & = 0 \\
%   2x+4y & = 0 
%   ~emphase#\end{WithArrows}@\right. \\
%   & \Leftrightarrow
%   \left\{~emphase#\begin{WithArrows}@[c]
%   x+2y & = 0 \Arrow[tikz=-]{the same equation}\\
%   x+2y & = 0 
%   ~emphase#\end{WithArrows}@\right. \\
%   & \Leftrightarrow x+2y=0 
% ~emphase#\end{WithArrows}@$
% \end{Verbatim}
%
% $\begin{WithArrows}
% \varphi(x,y)=0
%   & \Leftrightarrow (x+2y)^2+(2x+4y)^2 = 0 \Arrow{the numbers are real}\\
%   & \Leftrightarrow
%   \left\{\begin{WithArrows}[c]
%   x+2y & = 0 \\
%   2x+4y & = 0 
%   \end{WithArrows}\right. \\
%   & \Leftrightarrow
%   \left\{\begin{WithArrows}[c]
%   x+2y & = 0 \Arrow[tikz=-]{the same equation}\\
%   x+2y & = 0 
%   \end{WithArrows}\right. \\
%   & \Leftrightarrow x+2y=0 
% \end{WithArrows}$
%
% \bigskip
% However, one may want to draw an arrow between rows that are not in the same
% environment. For example, one may want to draw the following arrow :
%
% \bigskip
% $\begin{WithArrows}[CodeAfter = \Arrow[v]{1-2}{2-2}{division by $2$} ]
% \varphi(x,y)=0
%   & \Leftrightarrow (x+2y)^2+(2x+4y)^2 = 0 \\
%   & \Leftrightarrow
%   \left\{\begin{WithArrows}[c]
%   x+2y & = 0 \\
%   2x+4y & = 0 
%   \end{WithArrows}\right. \\
%   & \Leftrightarrow
%   \left\{\begin{WithArrows}[c]
%   x+2y & = 0 \\
%   x+2y & = 0 
%   \end{WithArrows}\right. \\
%   & \Leftrightarrow x+2y=0 
% \end{WithArrows}$
%
%
% \bigskip
% Such a construction is possible by using |\Arrow| in the |CodeAfter| option.
% Indeed, in |CodeAfter|, a special version of |\Arrow| is available (we will
% call it ``|\Arrow| in |CodeAfter|'').
%
% \smallskip
% A command |\Arrow| in |CodeAfter| takes three arguments :
% \begin{itemize}
% \item a specification of the start row of the arrow ;
% \item a specification of the end row of the arrow ;
% \item the label of the arrow.
% \end{itemize}
% As usual, it's also possible to give options within square brackets before or
% after the three arguments. However, these options are limited (see below).
% 
% \bigskip
% The specification of the row is constructed with the position of the concerned
% environment in the nesting tree, followed (after an hyphen) by the number of
% the row.
%
% \bigskip
% In the previous example, there are two environments |{WithArrows}| nested in
% the main environment |{WithArrows}|.
%
% $\begin{WithArrows}[TikzCode = {\path (#1) to node {#3} (#2) ; }]
% \varphi(x,y)=0
%   & \Leftrightarrow (x+2y)^2+(2x+4y)^2 = 0 \\
%   & \Leftrightarrow \color{blue}
%   \left\{\begin{WithArrows}[c]
%   x+2y & = 0 \Arrow{environment number 1}\\
%   2x+4y & = 0 
%   \end{WithArrows}\right. \\
%   & \Leftrightarrow \color{red}
%   \left\{\begin{WithArrows}[c]
%   x+2y & = 0 \Arrow{environment number 2}\\
%   x+2y & = 0 
%   \end{WithArrows}\right. \\
%   & \Leftrightarrow x+2y=0 
% \end{WithArrows}$
%
% \bigskip
% The arrow we want to draw starts in the row~$2$ of the sub-environment
% number~$1$ (and therefore, the specification is |1-2|) and ends in the row~$2$
% of the sub-environment number~$2$ (and therefore, the specification is |2-2|).
% We can draw the arrow with the following command |\Arrow| in |CodeAfter| :
% \begin{Verbatim}
% $\begin{WithArrows}[~emphase#CodeAfter = \Arrow{1-2}{2-2}{division by $2$}@ ]
% \varphi(x,y)=0
%   & \Leftrightarrow (x+2y)^2+(2x+4y)^2 = 0 \\
% .........
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}[CodeAfter = \Arrow{1-2}{2-2}{division by $2$} ]
% \varphi(x,y)=0
%   & \Leftrightarrow (x+2y)^2+(2x+4y)^2 = 0 \\
%   & \Leftrightarrow
%   \left\{\begin{WithArrows}[c]
%   x+2y & = 0 \\
%   2x+4y & = 0 
%   \end{WithArrows}\right. \\
%   & \Leftrightarrow
%   \left\{\begin{WithArrows}[c]
%   x+2y & = 0 \\
%   x+2y & = 0 
%   \end{WithArrows}\right. \\
%   & \Leftrightarrow x+2y=0 
% \end{WithArrows}$
% 
% \bigskip
% The options allowed for a command |\Arrow| in |CodeAfter| are : |ll|, |lr|,
% |rl|, |rr|, |v|, |xoffset|, |tikz| and |TikzCode|. Except |v|, which is
% specific to |\Arrow| in |CodeAfter|, all these options have their usual
% meaning.
%
% With the option |v|, the arrow drawn is vertical to an abscissa computed with
% the start row and the end row only : the intermediate lines are not taken into
% account unlike with the option |i|. Currently, the option |i| is not available
% for the command~|\Arrow| in |CodeAfter|. However, it's always possible to
% translate an arrow with |xoffset| (or |xshift| of Tikz).
% \begin{Verbatim}
% $\begin{WithArrows}[CodeAfter = \Arrow~emphase#[v]@{1-2}{2-2}{division by $2$} ]
% \varphi(x,y)=0
%   & \Leftrightarrow (x+2y)^2+(2x+4y)^2 = 0 \\
% .........
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}[CodeAfter = \Arrow[v]{1-2}{2-2}{division by $2$} ]
% \varphi(x,y)=0
%   & \Leftrightarrow (x+2y)^2+(2x+4y)^2 = 0 \\
%   & \Leftrightarrow
%   \left\{\begin{WithArrows}[c]
%   x+2y & = 0 \\
%   2x+4y & = 0 
%   \end{WithArrows}\right. \\
%   & \Leftrightarrow
%   \left\{\begin{WithArrows}[c]
%   x+2y & = 0 \\
%   x+2y & = 0 
%   \end{WithArrows}\right. \\
%   & \Leftrightarrow x+2y=0 
% \end{WithArrows}$
%
%  
% \interitem
% The package \pkg{witharrows} gives also another command available only in
% |CodeAfter|: the command |\MultiArrow|. This command draws a ``rak''. The list
% of the rows of the environment concerned by this rak are given in the first
% argument of the command |\MultiArrow|. This list is given with the syntax of
% the list in a |\foreach| command of \pkg{pgffor}.
%
%
% \begin{Verbatim}
% $\begin{WithArrows}[tikz = rounded corners,
%                     CodeAfter = {~emphase#\MultiArrow{1,...,4}{text}@} ]
% A & = B \\
%   & = C \\
%   & = D \\
%   & = E \\
%   & = F
% \end{WithArrows}$
% \end{Verbatim}
% 
% 
% $\begin{WithArrows}[tikz = rounded corners,
%                     CodeAfter = {\MultiArrow{1,...,4}{text}}]
% A & = B \\
%   & = C \\
%   & = D \\
%   & = E \\
%   & = F
% \end{WithArrows}$
%
% \medskip
% As of now, there is no option available for the command |\MultiArrow| (maybe
% in a future release).
% 
% 
% \bigskip
% \section{Arrows from outside environments \{WithArrows\}}
%
% If someone wants to draw arrows from outside the environments |{WithArrows}|,
% he can use the Tikz nodes created in the environments.
% 
% The Tikz name of a node created by \pkg{witharrows} is prefixed by |wa-|.
% Then, we have a list of numbers which give the position in the nesting tree
% and the row number in the environment. At the end, we have the suffixe |l| for
% a ``left node'' and |r| for a ``right node''.
% 
% \smallskip
% For illustrative purposes, we give an example of nested environments
% |{WithArrows}|, and, for each ``right node'', the name of that
% node.\footnote{There is an option |show-node-names| to show the names of these
% nodes.}
% 
% \medskip
% \[\begin{WithArrows}[show-nodes,show-node-names]
% A & \vartriangleleft B+B+B+B+B+B+B+B+B+B+B+B+B \\
% & \vartriangleleft \left\{
% \begin{WithArrows}[c]
% C & \vartriangleleft D \\
% E & \vartriangleleft F 
% \end{WithArrows}
% \right. \\
%  & \vartriangleleft 
% \left\{
% \begin{WithArrows}[c]
% G & \vartriangleleft H+H+H+H+H+H+H \\
% I & \vartriangleleft 
% \left\{
% \begin{WithArrows}
% J &\vartriangleleft K \\
% L &\vartriangleleft M 
% \end{WithArrows}
% \right.
% \end{WithArrows}
% \right. \\
%  & \vartriangleleft 
% \left\{
% \begin{WithArrows}[c]
% N & \vartriangleleft O \\
% P & \vartriangleleft Q 
% \end{WithArrows}
% \right.
% \end{WithArrows}\]
%
% \medskip
% The package \pkg{witharrows} provides some tools facilitating the use of these
% nodes:
% \begin{itemize}
% \item the command |\WithArrowsLastEnv| gives the number of the last
% environment of level~$0$;
%
% \item a name can be given to a given environment with the option |name| and,
% in this case, the nodes created in the environment will have aliases
% constructed with this name;
%
% \item the Tikz style |WithArrows/arrow| is the style used by \pkg{witharrows}
% when drawing an arrow\footnote{More precisely, this style is given to the Tikz
% option ``|every path|'' before drawing the arrow with the code of the option
% |TikzCode|. This style is modified (in TeX scopes) by the option |tikz| of
% \pkg{witharrows}.};
%
% \item the Tikz style |WithArrows/arrow/tips| is the style for the tip of the
% arrow (loaded by |WithArrows/arrow|).
% \end{itemize}
%
% For example, we can draw an arrow from 
% \texttt{wa-\WithArrowsLastEnv-2-1-2-r.south} to
% \texttt{wa-\WithArrowsLastEnv-3-2-r.north} with the following Tikz command.
%
% \begin{Verbatim}
% \begin{tikzpicture}[remember picture,overlay]
% \draw [WithArrows/arrow] 
%       ([xshift=3mm]wa-\WithArrowsLastEnv-2-1-2-r.south)
%    to ([xshift=3mm]wa-\WithArrowsLastEnv-3-2-r.north) ;
% \end{tikzpicture}
% \end{Verbatim}
%
% \[\begin{WithArrows}
% A & \vartriangleleft B+B+B+B+B+B+B+B+B+B+B+B+B \\
% & \vartriangleleft \left\{
% \begin{WithArrows}[c]
% C & \vartriangleleft D \\
% E & \vartriangleleft F 
% \end{WithArrows}
% \right. \\
%  & \vartriangleleft 
% \left\{
% \begin{WithArrows}[c]
% G & \vartriangleleft H+H+H+H+H+H+H \\
% I & \vartriangleleft 
% \left\{
% \begin{WithArrows}
% J &\vartriangleleft K \\
% L &\vartriangleleft M 
% \end{WithArrows}
% \right.
% \end{WithArrows}
% \right. \\
%  & \vartriangleleft 
% \left\{
% \begin{WithArrows}[c]
% N & \vartriangleleft O \\
% P & \vartriangleleft Q 
% \end{WithArrows}
% \right.
% \end{WithArrows}\]
%
% \begin{tikzpicture}[remember picture,overlay]
% \draw [WithArrows/arrow] 
%       ([xshift=3mm]wa-\WithArrowsLastEnv-2-1-2-r.south)
%    to ([xshift=3mm]wa-\WithArrowsLastEnv-3-2-r.north) ;
% \end{tikzpicture}
%
% \medskip
% In this case, it would be easier to use a command |\Arrow| in |CodeAfter| but
% this is an example to explain how the Tikz nodes created by \pkg{witharrows}
% can be used.
% 
% \bigskip
% In the following example, we create two environments |{WithArrows}| named
% ``|first|'' and ``|second|'' and we draw a line between a node of the first
% and a node of the second.
%
% \begin{Verbatim}
% $\begin{WithArrows}[~emphase#name=first@]
% A & = B \\
%   & = C 
% \end{WithArrows}$
%
% \bigskip
% $\begin{WithArrows}[~emphase#name=second@]
% A' & = B' \\
%    & = C'
% \end{WithArrows}$
%
% \begin{tikzpicture}[remember picture,overlay]
% \draw [WithArrows/arrow] 
%       ([xshift=3mm]~emphase#first@-1-r.south)
%    to ([xshift=3mm]~emphase#second@-1-r.north) ;
% \end{tikzpicture}
% \end{Verbatim}
% 
%
% \begin{center}
% $\begin{WithArrows}[name=first]
% A & = B \\
%   & = C 
% \end{WithArrows}$
% 
% \bigskip
% $\begin{WithArrows}[name=second]
% A' & = B' \\
%    & = C' 
% \end{WithArrows}$
% \end{center}
%
% \begin{tikzpicture}[remember picture,overlay]
% \draw [WithArrows/arrow] 
%       ([xshift=3mm]first-1-r.south)
%    to ([xshift=3mm]second-1-r.north) ;
% \end{tikzpicture}
% 
% \section{The environment \{DispWithArrows\}}
% \label{DispWithArrows}
% 
% As previously said, the environment |{WithArrows}| bears similarities with the
% environment |{aligned}| of |amsmath| (and |mathtools|). This extension also
% provides an environment |{DispWithArrows}| which is similar to the
% environments |{align}| and |{flalign}| of |amsmath|.
%
% \medskip
% The environment |{DispWithArrows}| must be used \emph{outside} math mode. Like
% |{align}|, it should be used in horizontal mode.
% \begin{Verbatim}
% \begin{~emphase#DispWithArrows@}
% A & = (a+1)^2 \Arrow{we expand} \\
%   & = a^2 + 2a + 1 
% \end{~emphase#DispWithArrows@}
% \end{Verbatim}
% \begin{DispWithArrows}
% A & = (a+1)^2 \Arrow{we expand} \\
%   & = a^2 + 2a + 1 
% \end{DispWithArrows}
%
% \medskip
% It's possible to use the command |\notag| (or |\nonumber|) to suppress a tag. 
% 
% It's possible to use the command |\tag| to put a special tag (e.g. $\star$).
%
% It's also possible to put a label to the line of an equation with the command
% |\label|.
% 
% These commands must be in the second column of the environment.
% \begin{Verbatim}
% \begin{DispWithArrows}
% A & = (a+1)^2 \Arrow{we expand} ~emphase#\notag@ \\
%   & = a^2 + 2a + 1 ~emphase#\tag{$\star$} \label{my-equation}@
% \end{DispWithArrows}
% \end{Verbatim}
% \begin{DispWithArrows}
% A & = (a+1)^2 \Arrow{we expand} \notag \\
%   & = a^2 + 2a + 1 \tag{$\star$} \label{my-equation}
% \end{DispWithArrows}
% A link to the equation \eqref{my-equation}. This link has been composed with
% |\eqref{my-equation}| (the command |\eqref| is a command of \pkg{amsmath}).
% 
% \medskip
% If \pkg{amsmath} (or \pkg{mathtools}) is loaded, it's also possible to use
% |\tag*| which, as in \pkg{amsmath}, typesets the tag without the parenthesis.
% For example, it's possible to use it to put the symbol |\square| of
% \pkg{amssymb}. This symbol is often used to mark the end of a
% proof.\footnote{Notice that the environment |{DispWithArrows}| is compatible
% with the command |\qedhere| of \pkg{amsthm}.}
% \begin{Verbatim}
% \begin{DispWithArrows}
% A & = (a+1)^2 \Arrow{we expand} \notag \\
%   & = a^2 + 2a + 1 ~emphase#\tag*{$\square$}@
% \end{DispWithArrows}
% \end{Verbatim}
% \begin{DispWithArrows}
% A & = (a+1)^2 \Arrow{we expand} \notag \\
%   & = a^2 + 2a + 1 \tag*{$\square$} 
% \end{DispWithArrows}
%
% \medskip
% It's also possible to suppress all the autogenerated numbers with the boolean
% option |notag| (or |nonumber|), at the global or environment level. There is
% also an environment |{DispWithArrows*}| which suppresses all these
% numbers.\footnote{Even in this case, it's possible to put a ``manual tag''
% with the command |\tag|.}
% \begin{Verbatim}
% \begin{~emphase#DispWithArrows*@}
% A & = (a+1)^2 \Arrow{we expand} \\
%   & = a^2 + 2a + 1 
% \end{~emphase#DispWithArrows*@}
% \end{Verbatim}
% \begin{DispWithArrows*}
% A & = (a+1)^2 \Arrow{we expand} \\
%   & = a^2 + 2a + 1 
% \end{DispWithArrows*}
%
% \medskip
% In fact, there is also another option |tagged-lines| which can be used to
% control the lines that will be tagged. The value of this option is a list of
% the numbers of the lines that must to be tagged. For example, with the option
% |tagged-lines = {first,3,last}|, only the first, the third and the last line
% of the environment will be tagged. There is also the special value |all| which
% means that all the lines will be tagged.
% \begin{Verbatim}
% \begin{DispWithArrows}[~emphase#tagged-lines = last@]
% A & = A_1 \Arrow{first stage} \\
%   & = A_2 \Arrow{second stage} \\
%   & = A_3 
% \end{DispWithArrows}
% \end{Verbatim}
% \begin{DispWithArrows}[tagged-lines = last]
% A & = A_1 \Arrow{first stage} \\
%   & = A_2 \Arrow{second stage} \\
%   & = A_3 
% \end{DispWithArrows}
%
% \bigskip
% With the option |fleqn|, the environment is composed flush left (in a way
% similar to the option |fleqn| of the standard classes of LaTeX). In this case,
% the left margin can be controlled with the option |mathindent| (with a name
% inspired by the parameter |\mathindent| of standard LaTeX). The default value
% of this parameter is 25~pt.
%
% \begin{Verbatim}
% \begin{DispWithArrows}[~emphase#fleqn,mathindent = 1cm@]
% A & = (a+1)^2 \Arrow{we expand} \\
%   & = a^2 + 2a + 1 
% \end{DispWithArrows}
% \end{Verbatim}
% \begin{DispWithArrows}[fleqn,mathindent = 1cm]
% A & = (a+1)^2 \Arrow{we expand} \\
%   & = a^2 + 2a + 1 
% \end{DispWithArrows}
%
% \medskip
% \emph{Remark} : By design, the option |fleqn| of \pkg{witharrows} is
% independent of the option |fleqn| of LaTeX. Indeed, since the environments of
% \pkg{witharrows} are meant to be used with arrows on the right side, the user
% may want to use \pkg{witharrows} with the option |fleqn| (in order to have
% more space on the right of the equations for the arrows) while still centering
% the classical equations.
%
% \bigskip
% If the package \pkg{amsmath} is loaded, it's possible to use the environment
% |{subequations}| and the command |\intertext| in the environments
% |{DispWithArrows}| and |{DispWithArrows*}| (and even the |\intertext| of
% \pkg{nccmath} if this package is loaded).
%
% If the option |leqno| is used as a class option, the labels will be composed
% on the left also for the environments |{DispWithArrows}| and
% |{DispWithArrows*}|.\footnote{The package \pkg{amsmath} has an option |leqno|
% but \pkg{witharrows}, of course, is not aware of that option: \pkg{witharrows}
% only checks the option |leqno| of the document class.}
%
% \bigskip
% If there is not enough space to put the tag at the end of a line, there is no
% automatic positioning of the label on the next line (as in the environments of
% \pkg{amsmath}). However, in |{DispWithArrows}|, the user can use the command
% |\tagnextline| to manually require the composition of the tag on the following
% line.
% \begin{Verbatim}
% \begin{DispWithArrows}[displaystyle]
% S_{2(p+1)}
% & =\sum_{k=1}^{2(p+1)} (-1)^k k^2 \\
% & \smash[b]{=\sum_{k=1}^{2p}(-1)^kk²
%    +(-1)^{2p+1}(2p+1)^2+(-1)^{2p+2}(2p+2)^2} ~emphase#\tagnextline@ \\
% &= S_{2p}-(2p+1)^2+(2p+2)^2\\
% &=p(2p+1)-(2p+1)^2+(2p+2)^2\\
% &= 2p^2+5p+3 
% \end{DispWithArrows}
% \end{Verbatim}
% \begin{center}
% \color{gray}\vrule%
% \begin{minipage}{275pt}\color{black}
% \begin{DispWithArrows}[displaystyle]
% S_{2(p+1)}
% & =\sum_{k=1}^{2(p+1)} (-1)^k k^2 \\
% & \smash[b]{=\sum_{k=1}^{2p}(-1)^kk^2+(-1)^{2p+1}(2p+1)^2+(-1)^{2p+2}(2p+2)^2} \tagnextline \\
% &= S_{2p}-(2p+1)^2+(2p+2)^2\\
% &= 2p^2+p-4p^2-4p-1+4p^2+8p+4\\
% &= 2p^2+5p+3 
% \end{DispWithArrows}
% \end{minipage}%
% \color{gray}\vrule
% \end{center}
% 
%
% \bigskip 
% The environment |{DispWithArrows}| is similar to the environment |{align}| of
% \pkg{amsmath}. However, |{DispWithArrows}| is not constructed upon |{align}|
% (in fact, it's possible to use \pkg{witharrows} without \pkg{amsmath}).
%
% There are differences between |{DispWithArrows}| and |{align}|. 
% \begin{itemize}
% \item The environment |{DispWithArrows}| allows only two columns.
% \item The environment |{DispWithArrows}| can not be inserted in an environment
% |{gather}| of \pkg{amsmath}.
% \item An environment |{DispWithArrows}| is always unbreakable (even with
% |\allowdisplaybreaks| of \pkg{amsmath}).
% \item The commands |\label|, |\tag|, |\notag| and |\nonumber| are allowed only
% in the second column.
% \item 
% \begin{bfseries}
% Last but not least, by default, the elements of a \texttt{\{DispWithArrows\}}
% are composed in \texttt{textstyle} and not in \texttt{displaystyle} (it's
% possible to change this point with the option \texttt{displaystyle}).
% \end{bfseries}
% \end{itemize}
% 
% \bigskip 
% Concerning the references, the package \pkg{witharrows} is compatible with the
% extensions \pkg{autonum}, \pkg{cleveref}, \pkg{fancyref}, \pkg{fncylab},
% \pkg{hyperref}, \pkg{listlbls}, \pkg{prettyref}, \pkg{refcheck},
% \pkg{refstyle}, \pkg{showlabels}, \pkg{smartref}, \pkg{typedref} and
% \pkg{varioref}, and with the options |showonlyrefs| and |showmanualtags| of
% \pkg{mathtools}.\footnote{We recall that \pkg{varioref}, \pkg{hyperref},
% \pkg{cleveref} and \pkg{autonum} must be loaded in this order. The package
% \pkg{witharrows} can be loaded anywhere.}
%
% It is not compatible with \pkg{showkeys} (not all the labels are shown).
%
% \bigskip
% The environments |{DispWithArrows}| and |{DispWithArrows*}| provide an option
% |wrap-lines|. With this option, the lines of the label are automatically
% wrapped on the right.\footnote{It's possible to avoid the hyphenations of the
% words with the option ``|align = flush left|'' of Tikz.}\label{wrap-lines}
%
% \begin{Verbatim}
% \begin{DispWithArrows*}[displaystyle,~emphase#wrap-lines@]
% S_n
% & = \frac1n \Re \left(\sum_{k=0}^{n-1}\bigl(e^{i\frac{\pi}{2n}}\bigr)^k\right)
% \Arrow{sum of terms of a geometric progression of ratio $e^{i\frac{2\pi}n}$}\\
% & = \frac1n \Re \left( \frac{1-\bigl(e^{i\frac{\pi}{2n}}\bigr)^n}
%                             {1-e^{i\frac{\pi}{2n}}}\right)
% \Arrow{This line has been wrapped automatically.} \\
% & = \frac1n \Re \left(\frac{1-i}{1-e^{i\frac{\pi}{2n}}}\right) 
% \end{DispWithArrows*}
% \end{Verbatim}
% \begin{DispWithArrows*}[displaystyle,wrap-lines]
% S_n
% & = \frac1n \Re \left(\sum_{k=0}^{n-1}\bigl(e^{i\frac{\pi}{2n}}\bigr)^k\right)
% \Arrow{sum of terms of a geometric progression of ratio $e^{i\frac{2\pi}n}$}\\
% & = \frac1n \Re \left( \frac{1-\bigl(e^{i\frac{\pi}{2n}}\bigr)^n}{1-e^{i\frac{\pi}{2n}}}\right)
% \Arrow{This line has been wrapped automatically.} \\
% & = \frac1n \Re \left(\frac{1-i}{1-e^{i\frac{\pi}{2n}}}\right) 
% \end{DispWithArrows*}
% 
% \bigskip
% The option |wrap-lines| doesn't apply to the environments |{WithArrows}|
% nested in an environment |{DispWithArrows}| or |{DispWithArrows*}|. However,
% it applies to the instructions |\Arrow| and |\MultiArrow| of the |CodeAfter|
% of the environments |{DispWithArrows}| or |{DispWithArrows*}|.
% 
%
%
% \section{Advanced features}
%
% 
% \subsection{The option TikzCode : how to change the shape of the arrows}
%
% \label{TikzCode}
%
% The option |TikzCode| allows the user to change the shape of the
% arrows.\footnote{If the option |wrap-lines| is used in an environment
% |{DispWithArrows}| or |{DispWithArrows*}|, the option |TikzCode| will have no
% effect for the arrows of this environment but only for the arrows in the
% nested environments |{WithArrows}|.}
%
% \smallskip
% For example, the options ``|up|'' and ``|down|'' described previously (cf.
% p.~\pageref{up-and-down}) are programmed internally with |TikzCode|.
% 
% \smallskip
% The value of this option must be a valid Tikz drawing instruction (with the
% final semicolon) with three markers |#1|, |#2| and |#3| for the start point,
% the end point and the label of the arrow.
%
% \bigskip
% By default, the value is the following:
% 
% \smallskip
% \qquad \verb|\draw (#1) to node {#3} (#2) ;|
%
%
% \bigskip
% In the following example, we replace this default path by a path with three
% segments (and the node overwriting the second segment).
% \begin{Verbatim}
% \begin{WithArrows}[ygap=5pt,interline=4mm,
%       ~emphase#TikzCode = {\draw[rounded corners]@
%       ~emphase#                  (~#1) -- ([xshift=5mm]~#1)@
%       ~emphase#                  -- node[circle,@
%       ~emphase#                          draw,@
%       ~emphase#                          auto = false,@
%       ~emphase#                          fill = gray!50,@
%       ~emphase#                          inner sep = 1pt] {\tiny ~#3}@ 
%       ~emphase#                  ([xshift=5mm]~#2)@
%       ~emphase#                  -- (~#2) ; }@]
% E & \Longleftrightarrow 3 (2x+4) = 6   \Arrow{$\div 3$} \\
%   & \Longleftrightarrow 2x+4 = 2       \Arrow{$-4$}     \\
%   & \Longleftrightarrow 2x = -2        \Arrow{$\div 2$} \\
%   & \Longleftrightarrow  x = -1
% \end{WithArrows}
% \end{Verbatim}
%
% 
% \[\begin{WithArrows}[ygap=5pt,
%       interline=4mm,
%       TikzCode = {\draw[rounded corners]
%                         (#1) 
%                         --
%                         ([xshift=5mm]#1)
%                         -- node[circle,
%                                 draw,
%                                 auto=false,
%                                 fill=gray!50,
%                                 inner sep = 1pt] {\tiny #3} 
%                         ([xshift=5mm]#2)
%                         --
%                         (#2) ; }]
% E & \Longleftrightarrow 3 (2x+4) = 6 
% \Arrow{$\div 3$}\\
%   & \Longleftrightarrow 2x+4 = 2 
% \Arrow{$-4$}\\
%   & \Longleftrightarrow 2x = -2 
% \Arrow{$\div 2$} \\
%   & \Longleftrightarrow x = -1
% \end{WithArrows}\]
%
% \bigskip
% The environments |{DispWithArrows}| and its starred version
% |{DispWithArrows*}| provide a command |\WithArrowsRightX| which can be used in
% a definition of |TikzCode|. This command gives the $x$-value of the right side
% of the composition box (taking into account the eventual tags of the
% equations). For an example of use, see p.~\pageref{example-WithArrowsRightX}.
%
%
% \bigskip
% \subsection{The command WithArrowsNewStyle}
%
% The extension \pkg{witharrows} provides a command |\WithArrowsNewStyle| to
% define styles in a way similar to the ``styles'' of Tikz.
%
% The command |\WithArrowsNewStyle| takes two mandatory arguments. The first is
% the name of the style and the second is a list of key-value pairs. The scope
% of the definition done by |\WithArrowsNewStyle| is the current TeX scope.
%
% The style can be used as a key at the document level (with
% |\WithArrowsOptions|) or at the environment level (in the optional arguments
% of |{WithArrows}| and |{DispWithArrows}|). The style can also be used in
% another command |\WithArrowsNewStyle|.
%
% For an example of use, see p.~\pageref{example-WithArrowsRightX}.
%
%
% \bigskip
% \subsection{Vertical positioning of the arrows}
% 
% There are four parameters for fine tuning of the vertical positioning of the
% arrows : |ygap|, |ystart|, |start-adjust| and |end-adjust|.
% 
% \medskip
% We first explain the behaviour when the parameters |start-adjust| and
% |end-adjust| are equal to zero:
% \begin{itemize}
% \item the option |ystart| sets the vertical distance between the base line of
% the text and the start of the arrow (default value: 0.4 ex);
% \item the option |ygap| sets the vertical distance between two consecutive
% arrows (default value: 0.4~ex).
% \end{itemize}
%
%
% \bigskip
% $\begin{WithArrows}[interline=1mm, adjust = 0pt]
%  (\cos x + \sin x)^2 & = \cos^2 x +2 \cos x \sin x + \sin^2 x\Arrow{}\tikz[remember picture] \coordinate (A) ; \\
%    & = \cos^2x + \sin^2x + 2\sin x\cos x \Arrow{} \\
%    & = 1 + \sin(2x) 
% \end{WithArrows}$
%
% \begin{tikzpicture}[remember picture,overlay,blue]
% \draw (wa-\WithArrowsLastEnv-1-r.south) to ++(1,0) coordinate (B) to ++(0.1,0) ;;
% \draw (A) to ++(1,0) coordinate (C) to ++(0.1,0) ;;
% \draw (B) -- (C) ;
% \draw[<-] (B) to ++(0,0.2) ;
% \draw[<-] (C) to ++(0,-0.2) ;
% \path (C) node[right=1mm] {\texttt{ystart}} ;
% \draw (wa-\WithArrowsLastEnv-2-r.north) to ++(3,0) coordinate (E) to ++(0.1,0);
% \draw (wa-\WithArrowsLastEnv-2-r.south) to ++(3,0) coordinate (F) to ++(0.1,0);
% \draw (E) -- (F) ;
% \draw[<-] (E) to ++(0,0.2) ;
% \draw[<-] (F) to ++(0,-0.2) ;
% \path (F) node[right=1mm] {\texttt{ygap}} ;
% \end{tikzpicture}
%
% \interitem 
% However, for aesthetic reasons, when it's possible, \pkg{witharrows} starts
% the arrow a bit higher (by an amount |start-adjust|) and ends the arrow a bit
% lower (by an amount |end-adjust|). By default, both parameters |start-adjust|
% and |end-adjust| are equal to $0.4$~ex.
%
% \bigskip
% Here is for example the behaviour without the mechanism of |start-adjust| and
% |end-adjust| (this was the standard behaviour for versions prior to 1.13).
% % \begin{Verbatim}
% $\begin{WithArrows}~emphase#[start-adjust=0pt, end-adjust=0pt]@
% A & = (a+1)^2 \Arrow{we expand} \\
%   & = a^2 + 2a + 1  
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}[start-adjust=0pt, end-adjust=0pt]
% A & = (a+1)^2 \Arrow{we expand} \\
%   & = a^2 + 2a + 1  
% \end{WithArrows}$
%
%
% \bigskip
% Here is the standard behaviour since version 1.13 (the parameters
% |start-adjust| and |end-ajust| are used with the default value $0.4$~ex). The
% arrow is longer and the result is more aesthetic.
% 
% \medskip
% $\begin{WithArrows}
% A & = (a+1)^2 \Arrow{we expand} \\
%   & = a^2 + 2a + 1  
% \end{WithArrows}$
%
%
% \bigskip
% It's also possible to use the option |adjust| which sets both |start-adjust|
% and |end-ajust|.
%
% \bigskip
% Since the mechanism of |start-adjust| and |end-ajust| has been added in
% version 1.13 of \pkg{witharrows}, that version is not stricty compatible with
% older versions. However, it's possible to restore the previous behaviour
% simply by setting |start-adjust| and |end-adjust| to $0$~pt:
% \begin{Verbatim}
% \WithArrowsOptions{adjust = 0pt}
% \end{Verbatim}
% 
% \bigskip
% \subsection{Footnotes in the environments of witharrows}
% 
% If you want to put footnotes in an environment |{WithArrows}| or
% |{DispWithArrows}|, you can use a pair |\footnotemark|--|\footnotetext|.
%
% \smallskip
% It's also possible to extract the footnotes with the help of the package
% \pkg{footnote} or the package \pkg{footnotehyper}.
%
% \smallskip
% If \pkg{witharrows} is loaded with the option |footnote| (with
% |\usepackage[footnote]{witharrows}| or with |\PassOptionsToPackage|), the
% package \pkg{footnote} is loaded (if it is not yet loaded) and it is used to
% extract the footnotes.
%
% \smallskip
% If \pkg{witharrows} is loaded with the option |footnotehyper|, the package
% \pkg{footnotehyper} is loaded (if it is not yet loaded) ant it is used to
% extract footnotes.
%
% \smallskip
% Caution: The packages \pkg{footnote} and \pkg{footnotehyper} are incompatible.
% The package \pkg{footnotehyper} is the successor of the package \pkg{footnote}
% and should be used preferently. The package \pkg{footnote} has some drawbacks,
% in particular: it must be loaded after the package \pkg{xcolor} and it is not
% perfectly compatible with \pkg{hyperref}.
%
% \medskip
% In this document, the package \pkg{witharrows} has been loaded with the option
% |footnotehyper| and we give an example with a footnote in the label of an
% arrow:
%
% \smallskip
% $\begin{WithArrows}
% A & = (a+b)^2 
% \Arrow{We expand\,\footnote{A footnote.}} \\
%    & = a^2+b^2+2ab
% \end{WithArrows}$
%
% \bigskip
% \subsection{Note for developpers}
%
% If you want to construct an environment upon an environment of
% \pkg{witharrows}, we recommand to call the environment with the construction
% |\WithArrows|-|\endWithArrows| or |\DispWithArrows|-|\endDispWithArrows| (and
% not |\begin{WithArrows}|-|\end{WithArrows}|, etc.).
%
% \smallskip
% By doing so, the error messages generated by \pkg{witharrows} will (usually)
% mention the name of your environment and they will be easier to understand by
% the final user.
%
% \smallskip
% By example, you can define an environment |{DWA}| which is an alias of
% |{DispWithArrows}|:
% \begin{BVerbatim}
% \NewDocumentEnvironment {DWA} {} {\DispWithArrows}{\endDispWithArrows}
% \end{BVerbatim}
% 
% \smallskip
% If you use this environment |{DWA}| in math mode, you will have the following
% error message:
% 
% \begin{BVerbatim}
% The environment {DWA} should be used only outside math mode.
% \end{BVerbatim}
% 
% \interitem
% Another example is the definition of the environment |{DispWithArrows*}|
% internally in the package \pkg{witharrows} by the following code:
% \begin{Verbatim}
% \NewDocumentEnvironment {DispWithArrows*} {}
%     {\WithArrowsOptions{notag}%
%      \DispWithArrows}
%     {\endDispWithArrows}
% \end{Verbatim}
% 
% \section{Examples}
%
% \subsection{With only one column}
%
% It's possible to use the environment |{WithArrows}| with making use of the
% left column only, or the right column only.
% %
% \begin{Verbatim}
% $\begin{WithArrows}
% & f(x) \ge g(x) \Arrow{by squaring both sides} \\
% & f(x)^2 \ge g(x)^2 \Arrow{by moving to left side} \\
% & f(x)^2 - g(x)^2 \ge 0 
% \end{WithArrows}$
% \end{Verbatim}
%
% $\begin{WithArrows}
% & f(x) \ge g(x) \Arrow{by squaring both sides} \\
% & f(x)^2 \ge g(x)^2 \Arrow{by moving to left side} \\
% & f(x)^2 - g(x)^2 \ge 0 
% \end{WithArrows}$
%
% \bigskip
% \subsection{MoveEqLeft}
%
% It's possible to use |\MoveEqLeft| of \pkg{mathtools} (if we don't want
% ampersand on the first line):
% %
% \begin{Verbatim}[formatcom=\small\color{gray}]
% $\begin{WithArrows}[interline=0.5ex]
% ~emphase#\MoveEqLeft@ \arccos(x) = \arcsin \frac45 + \arcsin \frac5{13} 
% \Arrow{because both are in $[-\frac{\pi}2,\frac{\pi}2]$} \\
% & \Leftrightarrow x = \sin\left(\arcsin\frac45 + \arcsin\frac5{13}\right) \\
% & \Leftrightarrow x = \frac45\cos\arcsin\frac5{13} + \frac5{13} \cos\arcsin\frac45 
% \Arrow{$\forall x \in [-1,1], \cos(\arcsin x) = \sqrt{1-x^2}$} \\
% & \Leftrightarrow x = \frac45\sqrt{1-\bigl(\frac5{13}\bigr)^2}
% + \frac5{13}\sqrt{1-\bigl(\frac45\bigr)^2} 
% \end{WithArrows}$
% \end{Verbatim}
%
%
% \medskip
% $\begin{WithArrows}[interline=0.5ex]
% \MoveEqLeft \arccos(x) = \arcsin \frac45 + \arcsin \frac5{13} 
% \Arrow{because both are in $[-\frac{\pi}2,\frac{\pi}2]$} \\
% & \Leftrightarrow x = \sin\left(\arcsin\frac45 + \arcsin\frac5{13}\right) \\
% & \Leftrightarrow x = \frac45\cos\arcsin\frac5{13} + \frac5{13} \cos\arcsin\frac45 
% \Arrow{$\forall x \in [-1,1], \cos(\arcsin x) = \sqrt{1-x^2}$} \\
% & \Leftrightarrow x = \frac45\sqrt{1-\bigl(\frac5{13}\bigr)^2}
% + \frac5{13}\sqrt{1-\bigl(\frac45\bigr)^2} 
% \end{WithArrows}$
%
%
% \bigskip
% \subsection{Modifying the shape of the nodes}
%
% It's possible to change the shape of the labels, which are Tikz nodes, by
% modifying the key ``|every node|'' of Tikz.
%
% \begin{Verbatim}
% \begin{WithArrows}%
%      [interline = 4mm,
%       tikz = {~emphase#every node/.style = {circle,@
%               ~emphase#                     draw,@
%               ~emphase#                     auto = false,@
%               ~emphase#                     fill = gray!50,@
%               ~emphase#                     inner sep = 1pt,@
%               ~emphase#                     font = \tiny}@}]
% E & \Longleftrightarrow 3 (2x+4) = 6 
% \Arrow{$\div 3$}\\
%   & \Longleftrightarrow 2x+4 = 2 
% \Arrow{$-4$}\\
%   & \Longleftrightarrow 2x = -2 
% \Arrow{$\div 2$} \\
%   & \Longleftrightarrow 2x = -1
% \end{WithArrows}
% \end{Verbatim}
%
% \[\begin{WithArrows}[%
%       interline = 4mm,
%       tikz = {every node/.style = {circle,
%                                    draw,
%                                    auto = false,
%                                    fill = gray!50,
%                                    inner sep = 1pt,
%                                    font = \tiny}}]
% E & \Longleftrightarrow 3 (2x+4) = 6 
% \Arrow{$\div 3$}\\
%   & \Longleftrightarrow 2x+4 = 2 
% \Arrow{$-4$}\\
%   & \Longleftrightarrow 2x = -2 
% \Arrow{$\div 2$} \\
%   & \Longleftrightarrow 2x = -1
% \end{WithArrows}\]
%
%
% \bigskip
% \subsection{Examples with the option TikzCode}
%
% We recall that the option |TikzCode| is the Tikz code used by \pkg{witharrows}
% to draw the arrows.\footnote{If an environment |{DispWithArrows}| or
% |{DispWithArrows*}| is used with the option |wrap-lines|, the value of the
% option |TikzCode| is not used for this environment (but is used for the
% environments nested inside).}
%
% \smallskip
% The value by defaut of |TikzCode| is \verb|\draw (#1) to node {#3} (#2) ;|
% where the three markers |#1|, |#2| and |#3| represent the start row, the end
% row and the label of the arrow.
%
%
% \bigskip
% \subsubsection{Example 1}
% In the following example, we define the value of |TikzCode| with two
% instructions |\path| : the first instruction draws the arrow itself and the
% second puts the label in a Tikz node in the rectangle delimited by the arrow.
%
% \begin{Verbatim}
% \begin{DispWithArrows*}%
%       [displaystyle,
%        ygap = 2mm,
%        ystart = 0mm,
%        ~emphase#TikzCode = {\draw (~#1) -- ++(4.5cm,0) |- (~#2) ;@
%        ~emphase#            \path (~#1) -- (~#2) @
%        ~emphase#                   node[text width = 4.2cm, right, midway] {~#3} ;}@]
% S_n
% & = \frac1n \sum_{k=0}^{n-1}\cos\bigl(\tfrac{\pi}2\cdot\tfrac kn\bigr)
% ...........
% \end{Verbatim}
%
%
% \bigskip
% \begin{DispWithArrows*}[
%        displaystyle,
%        ygap = 2mm,
%        ystart = 0mm,
%        TikzCode = {\draw (#1) -- ++(4.5cm,0) |- (#2) ;
%                    \path (#1) -- (#2) 
%                           node[text width = 4.2cm, right, midway] {#3} ;}]
% S_n
% & = \frac1n \sum_{k=0}^{n-1}\cos\bigl(\tfrac{\pi}2\cdot\tfrac kn\bigr)
% \Arrow{$\cos x = \Re(e^{ix})$}\\
% & = \frac1n\sum_{k=0}^{n-1} \Re\left(e^{i\frac{k\pi}{2n}}\right)
% \Arrow{$\Re(z+z')=\Re(z)+\Re(z')$}\\
% & = \frac1n \Re\left(\sum_{k=0}^{n-1} e^{i\frac{k\pi}{2n}}\right)
% \Arrow{$\exp$ is a morphism for $\times$ et $+$} \\
% & = \frac1n \Re \left(\sum_{k=0}^{n-1}\bigl(e^{i\frac{\pi}{2n}}\bigr)^k\right)
% \Arrow{sum of terms of a geometric progression of ratio $e^{i\frac{2\pi}n}$}\\
% & = \frac1n \Re \left( \frac{1-\bigl(e^{i\frac{\pi}{2n}}\bigr)^n}{1-e^{i\frac{\pi}{2n}}}\right)\\
% & = \frac1n \Re \left(\frac{1-i}{1-e^{i\frac{\pi}{2n}}}\right) 
% \end{DispWithArrows*}
%
% \bigskip
% \subsubsection{Example 2}
%
% \label{example-WithArrowsRightX}
% It's possible to modify the previous example to have the ``|text width|''
% automatically computed with the right margin (in a way similar as the
% |wrap-lines| option) in the environments |{DispWithArrows}| and
% |{DispWithArrows*}|. In the definition of |TikzCode|, we use the command
% |\WithArrowsRightX| which is the $x$-value of the right margin of the current
% composition box (it's a TeX command and not a dimension). For lisibility, we
% use a style. This example requires the Tikz library \pkg{calc}.
%
% \begin{Verbatim}
% \WithArrowsNewStyle{MyStyle}       
%   {displaystyle,
%    ygap = 2mm,
%    xoffset = 0pt,
%    ystart = 0mm,
%    TikzCode = {\path let \p1 = (~#~#1)
%                      in (~#~#1)
%                          -- node [anchor = west, 
%                                   text width = {~emphase#\WithArrowsRightX@ - \x1 - 0.5 em}] 
%                                  {~#~#3} 
%                         (~#~#2) ;
%                \draw let \p1 = (~#~#1) 
%                      in (~#~#1) -- ++(~emphase#\WithArrowsRightX@ - \x1,0) |- (~#~#2) ; }}
% \end{Verbatim}
%
% \begin{Verbatim}
%\begin{DispWithArrows}[MyStyle]
%   S_n
%   & = \frac1n \sum_{k=0}^{n-1}\cos\bigl(\tfrac{\pi}2\cdot\tfrac kn\bigr)
%   \Arrow{$\cos x = \Re(e^{ix})$}\\
% ...........
% \end{Verbatim}
% 
% \WithArrowsNewStyle{MyStyle}       
% {displaystyle,
%  ygap = 2mm,
%  xoffset = 0pt,
%  ystart = 0mm,
%  TikzCode = {\path let \p1 = (##1)
%                    in (##1)
%                        -- node [anchor = west, 
%                                 text width = {\WithArrowsRightX - \x1 - 0.5 em}] {##3} 
%                       (##2) ;
%              \draw let \p1 = (##1) 
%                    in (##1) -- ++(\WithArrowsRightX - \x1,0) |- (##2) ; }}
%
%\begin{DispWithArrows}[MyStyle]
% S_n
% & = \frac1n \sum_{k=0}^{n-1}\cos\bigl(\tfrac{\pi}2\cdot\tfrac kn\bigr)
% \Arrow{$\cos x = \Re(e^{ix})$}\\
% & = \frac1n\sum_{k=0}^{n-1} \Re\left(e^{i\frac{k\pi}{2n}}\right)
% \Arrow{$\Re(z+z')=\Re(z)+\Re(z')$}\\
% & = \frac1n \Re\left(\sum_{k=0}^{n-1} e^{i\frac{k\pi}{2n}}\right)
% \Arrow{$\exp$ is a morphism for $\times$ et $+$} \\
% & = \frac1n \Re \left(\sum_{k=0}^{n-1}\bigl(e^{i\frac{\pi}{2n}}\bigr)^k\right)
% \Arrow{sum of terms of a geometric progression of ratio $e^{i\frac{2\pi}n}$}\\
% & = \frac1n \Re \left( \frac{1-\bigl(e^{i\frac{\pi}{2n}}\bigr)^n}{1-e^{i\frac{\pi}{2n}}}\right)\\
% & = \frac1n \Re \left(\frac{1-i}{1-e^{i\frac{\pi}{2n}}}\right) 
% \end{DispWithArrows}
% 
%
% 
% \bigskip
% \subsubsection{Example 3}
% 
% In the following example, we change the shape of the arrow depending on wether
% the start row is longer than the end row or not. This example requires the
% Tikz library \pkg{calc}.
% 
% \begin{Verbatim}
% \begin{WithArrows}[ll,interline=5mm,xoffset=5mm,
%       ~emphase#TikzCode  = {\draw[rounded corners,@
%       ~emphase#                   every node/.style = {circle,@
%       ~emphase#                                        draw,@
%       ~emphase#                                        auto = false,@
%       ~emphase#                                        inner sep = 1pt,@
%       ~emphase#                                        fill = gray!50,@
%       ~emphase#                                        font = \tiny }]@ 
%       ~emphase#                   let \p1 = (~#1),@
%       ~emphase#                       \p2 = (~#2)@
%       ~emphase#                   in \ifdim \x1 > \x2@
%       ~emphase#                        (\p1) -- node {~#3} (\x1,\y2) -- (\p2)@
%       ~emphase#                      \else@
%       ~emphase#                        (\p1) -- (\x2,\y1) -- node {~#3} (\p2)@
%       ~emphase#                      \fi ;}@]
% E & \Longleftrightarrow \frac{(x+4)}3 + \frac{5x+3}5 = 7 
% \Arrow{$\times 15$}\\
%   & \Longleftrightarrow 5(x+4) + 3(5x+3) = 105 \\
%   & \Longleftrightarrow 5x+20 + 15x+9 = 105 \\
%   & \Longleftrightarrow 20x+29 = 105 
% \Arrow{$-29$}\\
%   & \Longleftrightarrow 20x = 76 
% \Arrow{$\div 20$}\\
%   & \Longleftrightarrow x = \frac{38}{10} 
% \end{WithArrows}
% \end{Verbatim}
%
%
% \[\begin{WithArrows}[ll,interline=5mm,xoffset=5mm,
%       TikzCode  = {\draw[rounded corners,
%                          every node/.style = {circle,
%                                               draw,
%                                               auto = false,
%                                               inner sep = 1pt,
%                                               fill = gray!50,
%                                               font = \tiny}] 
%                          let \p1 = (#1),
%                              \p2 = (#2)
%                          in \ifdim \x1 > \x2
%                               (\p1) -- node {#3} (\x1,\y2) -- (\p2)
%                             \else
%                               (\p1) -- (\x2,\y1) -- node {#3} (\p2)
%                             \fi ;}]
% E & \Longleftrightarrow \frac{(x+4)}3 + \frac{5x+3}5 = 7 
% \Arrow{$\times 15$}\\
%   & \Longleftrightarrow 5(x+4) + 3(5x+3) = 105 \\
%   & \Longleftrightarrow 5x+20 + 15x+9 = 105 \\
%   & \Longleftrightarrow 20x+29 = 105 
% \Arrow{$-29$}\\
%   & \Longleftrightarrow 20x = 76 
% \Arrow{$\div 20$}\\
%   & \Longleftrightarrow x = \frac{38}{10} 
% \end{WithArrows}\]
%
%
% 
% \subsection{Automatic numbered loop}
%
% Assume we want to draw a loop of numbered arrows. In this purpose, it's
% possible to write a dedicated command |\NumberedLoop| which will do the job
% when used in |CodeAfter|. In the following example, we write this command with
% |\NewDocumentCommand| of \pkg{xparse} and |\foreach| of \pkg{pgffor} (both
% packages are loaded when \pkg{witharrows} is loaded).
%
% \begin{Verbatim}
% \NewDocumentCommand \NumberedLoop {}
%         {\foreach \j in {2,...,\WithArrowsNbLines} 
%               { \pgfmathtruncatemacro{\i}{\j-1}
%                 \Arrow[rr]{\i}{\j}{\i} }
%          \Arrow[rr,xoffset=1cm,tikz=<-]{1}{\WithArrowsNbLines}{\WithArrowsNbLines}}
% \end{Verbatim}
% 
% The command |\WithArrowsNbLines| is a command available in |CodeAfter| which
% gives the total number of lines (=rows) of the current environment (it's a
% command and not a counter).
%
%
% \bigskip
% \begin{Verbatim}
% $\begin{WithArrows}[~emphase#CodeAfter = \NumberedLoop@]
% a.\;& f \text{ est continuous on } E \\
% b.\;& f \text{ est continuous in } 0 \\
% c.\;& f \text{ is bounded on the unit sphere} \\
% d.\;& \exists K > 0\quad \forall x \in E\quad \|f(x)\| \le K \|x\| \\
% e.\;& f \text{ is lipschitzian} 
% \end{WithArrows}$
% \end{Verbatim}
% 
% \bigskip
% \begin{scope}
% \NewDocumentCommand \NumberedLoop {}
%         {\foreach \j in {2,...,\WithArrowsNbLines} 
%               { \pgfmathtruncatemacro{\i}{\j-1}
%                 \Arrow[rr]{\i}{\j}{\i} }
%          \Arrow[rr,xoffset=1cm,tikz=<-]{1}{\WithArrowsNbLines}{\WithArrowsNbLines}}
%
%
% $\begin{WithArrows}[CodeAfter = \NumberedLoop]
% a.\;& f \text{ est continuous on } E \\
% b.\;& f \text{ est continuous in } 0 \\
% c.\;& f \text{ is bounded on the unit sphere} \\
% d.\;& \exists K > 0\quad \forall x \in E\quad \|f(x)\| \le K \|x\| \\
% e.\;& f \text{ is lipschitzian} 
% \end{WithArrows}$
%
%
% \bigskip
% As usual, it's possible to change the characteristic of both arrows and nodes
% with the option |tikz|. However, if we want to change the style to have, for
% example, numbers in parenthesis, the best way is to change the value of
% |TikzCode|:
%
% \begin{Verbatim}
% TikzCode = {\draw (~#1) to node {\footnotesize (~#3)} (~#2) ;}
% \end{Verbatim}
%
% \WithArrowsOptions{TikzCode = {\draw (#1) to node {\footnotesize (#3)} (#2) ;}}
%
% $\begin{WithArrows}[CodeAfter = \NumberedLoop]
% a.\;& f \text{ est continuous on } E \\
% b.\;& f \text{ est continuous in } 0 \\
% c.\;& f \text{ is bounded on the unit sphere} \\
% d.\;& \exists K > 0\quad \forall x \in E\quad \|f(x)\| \le K \|x\| \\
% e.\;& f \text{ is lipschitzian}  
% \end{WithArrows}$
%
% \end{scope}
%
% \vspace{2cm}
% 
% \section{Implementation}
%
% \subsection{Declaration of the package and extensions loaded}
%
%
% First, \pkg{tikz} and some Tikz libraries are loaded before the
% |\ProvidesExplPackage|. They are loaded this way because |\usetikzlibrary| in
% |expl3| code fails.\footnote{cf.
%   |tex.stackexchange.com/questions/57424/using-of-usetikzlibrary-in-an-expl3-package-fails|}
% 
%    \begin{macrocode}
\RequirePackage{tikz}
\usetikzlibrary{arrows.meta,bending}
\RequirePackage{expl3}[2019/02/15]
%    \end{macrocode}
%
% \bigskip
% Then, we can give the traditional declaration of a package written with
% |expl3|:
%    \begin{macrocode}
\RequirePackage{l3keys2e}
\ProvidesExplPackage
  {witharrows}
  {\myfiledate}
  {\myfileversion}
  {Draws arrows for explanations on the right}
%    \end{macrocode}
%
% \bigskip
% The package \pkg{xparse} will be used to define the environments
% |{WithArrows}|, |{DispWithArrows}|, |{DispWithArrows*}| and the commands
% |\Arrow|, |\WithArrowsOptions| and |\WithArrowsNewStyle|.
%    \begin{macrocode}
\RequirePackage { xparse } [ 2018-10-17 ]
%    \end{macrocode}
%
% \bigskip
% \subsection{The packages footnote and footnotehyper}
%
% A few options can be given to the package \pkg{witharrows} when it is loaded
% (with |\usepackage|, |\RequirePackage| or |\PassOptionsToPackage|). Currently
% (version \myfileversion), there are two such options: |footnote| and
% |footnotehyper|. With the option |footnote|, \pkg{witharrows} loads
% \pkg{footnote} and uses it to extract the footnotes from the environments
% |{WithArrows}|. Idem for the option |footnotehyper|.
%
% \medskip
% The boolean |\g_@@_footnotehyper_bool| will indicate if the option
% |footnotehyper| is used.
%    \begin{macrocode}
\bool_new:N \g_@@_footnotehyper_bool
%    \end{macrocode}
%
% \medskip
% The boolean |\g_@@_footnote_bool| will indicate if the option |footnote| is
% used, but quicky, it will also be set to |true| if the option |footnotehyper|
% is used.
%    \begin{macrocode}
\bool_new:N \g_@@_footnote_bool
%    \end{macrocode}
%
% \bigskip
%    \begin{macrocode}
\cs_new_protected:Npn \@@_msg_new:nn { \msg_new:nnn { witharrows } }
\cs_new_protected:Npn \@@_msg_new:nnn { \msg_new:nnnn { witharrows } }
\cs_new_protected:Npn \@@_msg_redirect_name:nn 
  { \msg_redirect_name:nnn { witharrows } }
%    \end{macrocode}
% 
% \medskip
% We define a set of keys |WithArrows/package| for these options.
%    \begin{macrocode}
\keys_define:nn { WithArrows / package }
  { 
    footnote .bool_gset:N = \g_@@_footnote_bool ,
    footnotehyper .bool_gset:N = \g_@@_footnotehyper_bool ,
    unknown .code:n = 
      \msg_fatal:nn { witharrows } { Option~unknown~for~package } 
  }
%    \end{macrocode}
%
%    \begin{macrocode}          
\@@_msg_new:nn { Option~unknown~for~package }
  { 
    You~can't~use~the~option~'\l_keys_key_tl'~when~loading~the~
    package~witharrows.~Try~to~use~the~command~
    \token_to_str:N\WithArrowsOptions. 
  }
%    \end{macrocode}
%
%
% \bigskip
% We process the options when the package is loaded (with |\usepackage|).
%    \begin{macrocode}
\ProcessKeysOptions { WithArrows / package }
%    \end{macrocode}
% 
%
% \medskip
%    \begin{macrocode}
\@@_msg_new:nn { Option~incompatible~with~Beamer }
  { 
    The~option~'\l_keys_key_tl'\ is~incompatible~
    with~Beamer~because~Beamer~has~its~own~system~to~extract~footnotes. 
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_msg_new:nn { footnote~with~footnotehyper~package }
  { 
    You~can't~use~the~option~'footnote'~because~the~package~
    footnotehyper~has~already~been~loaded.~
    If~you~want,~you~can~use~the~option~'footnotehyper'~and~the~footnotes~  
    within~the~environments~of~witharrows~will~be~extracted~with~the~tools~
    of~the~package~footnotehyper. 
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_msg_new:nn { footnotehyper~with~footnote~package }
  { 
    You~can't~use~the~option~'footnotehyper'~because~the~package~
    footnote~has~already~been~loaded.~
    If~you~want,~you~can~use~the~option~'footnote'~and~the~footnotes~  
    within~the~environments~of~witharrows~will~be~extracted~with~the~tools~
    of~the~package~footnote. 
  }
%    \end{macrocode}
%
% \medskip
%    \begin{macrocode}
\bool_if:NT \g_@@_footnote_bool 
  { 
    \@ifclassloaded { beamer }
      { \msg_fatal:nn { witharrows } { Option~incompatible~with~Beamer } }
      { }
    \@ifpackageloaded { footnotehyper }
      { \msg_fatal:nn { witharrows } { footnote~with~footnotehyper~package } }
      { }
    \usepackage { footnote } 
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\bool_if:NT \g_@@_footnotehyper_bool 
  { 
    \@ifclassloaded { beamer }
      { \msg_fatal:nn { witharrows } { Option~incompatible~with~Beamer } }
      { }
    \@ifpackageloaded { footnote }
      { \msg_fatal:nn { witharrows } { footnotehyper~with~footnote~package } }
      { }
    \usepackage { footnotehyper }
    \bool_gset_true:N \g_@@_footnote_bool 
  }
%    \end{macrocode}
% The flag |\g_@@_footnote_bool| is raised and so, we will only have to test
% |\g_@@_footnote_bool| in order to know if we have to insert an environnement
% |{savenotes}| (the |\begin{savenotes}| is in |\@@_pre_environment:n| and
% |\end{savenotes}| at the end of the environments |{WithArrows}| and
% |{DispWithArrows}|).
%
% \bigskip
% \subsection{The class option leqno}
%
% The boolean |\c_@@_leqno_bool| will indicate if the class option |leqno| is
% used. When this option is used in LaTeX, the command |\@eqnnum| is redefined
% (as one can see in the file |leqno.clo|). That's enough to put the labels on
% the left in our environments |{DispWithArrows}| and |{DispWithArrows*}|.
% However, that's not enough when our option |wrap-lines| is used. That's why we
% have to know if this option is used as a class option. With the following
% programmation, |leqno| \emph{can't} be given as an option of \pkg{witharrows}
% (by design).
%    \begin{macrocode}
\bool_new:N \c_@@_leqno_bool
\DeclareOption { leqno } { \bool_set_true:N \c_@@_leqno_bool }
\DeclareOption* { }
\ProcessOptions* 
%    \end{macrocode}
%
% 
%
% \bigskip
% \subsection{Some technical definitions}
%
%    \begin{macrocode}
\cs_new_protected:Npn \@@_error:n { \msg_error:nn { witharrows } }
\cs_new_protected:Npn \@@_error:nn  { \msg_error:nnn { witharrows } }
\cs_generate_variant:Nn \@@_error:nn { n x }
%    \end{macrocode}
% 
%    \begin{macrocode}
\cs_new_protected:Nn \@@_bool_new:N
  {
    \bool_if_exist:NTF #1
      { \bool_set_false:N #1 }
      { \bool_new:N #1 }
  }
%    \end{macrocode}
%
% \medskip
% We create booleans in order to know if some packages are loaded. For example,
% for the package \pkg{amsmath}, the boolean is called
% |\c_@@_amsmath_loaded_bool|.\footnote{It's not possible to use
%   |\@ifpackageloaded| in the core of the functions because |\@ifpackageloaded|
%   is available only in the preamble.}
%    \begin{macrocode}
\AtBeginDocument 
  { 
    \clist_map_inline:nn
      { 
        amsmath, amsthm, autonum, cleveref, hyperref, mathtools, showlabels,
        typedref, varwidth 
      }
      {
        \bool_new:c { c_@@_#1_loaded_bool }
        \@ifpackageloaded { #1 }
          { \bool_set_true:c { c_@@_#1_loaded_bool } }
          { } 
      }
  }
%    \end{macrocode}
%
% \bigskip
% We define a command |\@@_strcmp:nn| to compare two token lists. It will be
% available wether the engine is pdfTeX, XeTeX or LuaTeX.
%    \begin{macrocode}
\sys_if_engine_luatex:TF
  { 
    \cs_new_protected:Nn \@@_strcmp:nn 
      { \lua_now:e { l3kernel.strcmp('#1','#2') } } 
  }
  { \cs_new_protected:Nn \@@_strcmp:nn { \pdftex_strcmp:D { #1 } { #2 } } }
%    \end{macrocode}
%
% \bigskip
% We can now define a command |\@@_sort_seq:N| which will sort a sequence.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_sort_seq:N 
  { 
    \seq_sort:Nn #1
    { 
      \int_compare:nNnTF 
        { 
          \@@_strcmp:nn 
            { \str_lower_case:n { ##1 } } 
            { \str_lower_case:n { ##2 } } 
        } 
        > 0
        \sort_return_swapped:
        \sort_return_same:    
    }
  }
%    \end{macrocode}
% 
% \bigskip
% The following variant will be used in the following command.
%    \begin{macrocode}
\cs_generate_variant:Nn \seq_set_split:Nnn { N x x }
%    \end{macrocode}
% 
% \bigskip
% The command |\@@_save:N| saves a \pkg{expl3} variable by creating a global
% version of the variable. For a variable named |\l_|\texttt{\slshape
%   name}|_|\texttt{\slshape type}, the corresponding global variable will be
% named |\g_|\texttt{\slshape name}|_|\texttt{\slshape type}. The type of the
% variable is determinated by the suffix \texttt{\slshape type} and is used to
% apply the corresponding \pkg{expl3} commands.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_save:N
  { 
    \seq_set_split:Nxx \l_tmpa_seq 
       { \char_generate:nn { `_ } { 12 } } 
       { \cs_to_str:N #1 }
    \seq_pop_left:NN \l_tmpa_seq \l_tmpa_tl
%    \end{macrocode}
% The string |\l_tmpa_str| will contains the \emph{type} of the variable.
%    \begin{macrocode}
    \str_set:Nx \l_tmpa_str { \seq_item:Nn \l_tmpa_seq { -1 } }
    \use:c { \l_tmpa_str _if_exist:cF }
      { g _\seq_use:Nnnn \l_tmpa_seq _ _ _ }
      { 
        \use:c { \l_tmpa_str _new:c }
          { g _\seq_use:Nnnn \l_tmpa_seq _ _ _ } 
      }
    \use:c { \l_tmpa_str _gset_eq:cN } 
      { g _\seq_use:Nnnn \l_tmpa_seq _ _ _ } #1 
  }
%    \end{macrocode}
% 
% \medskip
% The command |\@@_restore:N| affects to the \pkg{expl3} variable the value of
% the (previously) set value of the corresponding \emph{global} variable.
%    \begin{macrocode}  
\cs_new_protected:Nn \@@_restore:N 
  { 
    \seq_set_split:Nxx \l_tmpa_seq 
      { \char_generate:nn { `_ } { 12 } } 
      { \cs_to_str:N #1 }
    \seq_pop_left:NN \l_tmpa_seq \l_tmpa_tl
    \str_set:Nx \l_tmpa_str { \seq_item:Nn \l_tmpa_seq { -1 } }
    \use:c { \l_tmpa_str _set_eq:Nc } 
      #1 { g_\seq_use:Nnnn \l_tmpa_seq _ _ _ } 
  }
%    \end{macrocode}
% 
% 
% \bigskip
% We define a Tikz style |@@_node_style| for the |l|-nodes and |r|-nodes that
% will be created in the |\halign|. These nodes are Tikz nodes of shape
% ``rectangle'' but with zero width. An arrow between two nodes starts from the
% \emph{south} anchor of the first node and arrives at the \emph{north} anchor
% of the second node.
%    \begin{macrocode}
\tikzset
  { 
    @@_node_style / .style = 
      { 
        above = \l_@@_ystart_dim ,
        inner~sep = \c_zero_dim ,
        minimum~width = \c_zero_dim ,
        minimum~height = \l_@@_ygap_dim
      }
  }
%    \end{macrocode}
% If the user uses the option |show-nodes| (it's a \pkg{l3keys} option), the
% Tikz options |draw| and |red| will be appended to this style. This feature may
% be useful for debugging.\footnote{The |v|-nodes, created near the end of line
%   in |{DispWithArrows}| and |{DispWithArrows*}| are not shown with the option
%   |show-nodes|.}
%
% 
% \bigskip
% The style |@@_standard| is loaded in standard in the |{tikzpicture}| we need.
% The names of the nodes are prefixed by |wa| (by security) but also by a prefix
% which is the position-in-the-tree of the nested environments.
%    \begin{macrocode}
\tikzset
  { 
    @@_standard / .style = 
      { 
        remember~picture ,
        overlay ,
        name~prefix = wa - \l_@@_prefix_str -
      }
  }
%    \end{macrocode}
% 
% \bigskip
% We also define a style for the tips of arrow. The final user of the extension
% \pkg{witharrows} will use this style if he wants to draw an arrow directly
% with a Tikz command in his document (probably using the Tikz nodes created by
% |{WithArrows}| in the |\halign|).
%    \begin{macrocode}
\tikzset
  { 
    WithArrows / arrow / tips / .style = 
      { > = { Straight~Barb [ scale = 1.2 , bend ] } } 
  }
%    \end{macrocode}
%
% \bigskip
% The style |WithArrows/arrow| will be used to draw the arrows (more precisely,
% it will be passed to |every~path|).
%    \begin{macrocode}
\tikzset 
 { WithArrows / arrow / .style  = 
   { align = left ,
%    \end{macrocode}
%
% We have put the option |align = left| because we want to give the user the
% possibility of using |\\| in the labels.
%    \begin{macrocode}
     auto = left ,
     font = \small \itshape ,
     WithArrows / arrow / tips ,
     bend~left = 45 ,
     -> 
   }
 }
%    \end{macrocode}
%
% \bigskip
% In order to increase the interline in the environments |{WithArrows}|,
% |{DispWithArrows}|, etc., we will use the command |\spread@equation| of
% \pkg{amsmath}. When used, this command becomes no-op (in the current TeX
% group). Therefore, it will be possible to use the environments of
% \pkg{amsmath} (e.g. |{aligned}|) in an environment |{WithArrows}|.
% 
% Nevertheless, we want the extension \pkg{witharrows} available without
% \pkg{amsmath}. That's why we give a definition of |\spread@equation| if
% \pkg{amsmath} is not loaded (we put the code in a |\AtBeginDocument| because
% the flag |\c_@@_amsmath_loaded_bool| is itself set in a |\AtBeginDocument|).
%    \begin{macrocode}
\AtBeginDocument 
  {
    \bool_if:NF \c_@@_amsmath_loaded_bool
      { 
        \cs_set_protected:Npn \spread@equation
          { 
            \openup \jot   
            \cs_set_eq:NN \spread@equation \prg_do_nothing:
          }
      } 
  }
%    \end{macrocode}
%
% \bigskip
% \subsection{Variables}
%
% The boolean |\l_@@_in_WithArrows_bool| will be raised in an environment
% |{WithArrows}| and the boolean |\l_@@_in_dispwitharrows_bool| in an
% environment |{DispWithArrows}| or |{DispWithArrows*}|. The boolean
% |\l_@@_in_CodeAfter_bool| will be raised during the execution of the
% |CodeAfter| (option |CodeAfter|).
%    \begin{macrocode}
\bool_new:N \l_@@_in_WithArrows_bool
\bool_new:N \l_@@_in_DispWithArrows_bool
\bool_new:N \l_@@_in_CodeAfter_bool
%    \end{macrocode}
%
% The following sequence is the position of the last environment |{WithArrows}|
% in the tree of the nested environments |{WithArrows}|.
%    \begin{macrocode}
\seq_new:N \g_@@_position_in_the_tree_seq
\seq_gput_right:Nn \g_@@_position_in_the_tree_seq 1
%    \end{macrocode}
%
% \bigskip
% The following counter will give the number of the last environment
% |{WithArrows}| of level~$0$. This counter will be used only in the definition
% of |\WithArrowsLastEnv|.
%    \begin{macrocode}
\int_new:N \g_@@_last_env_int
%    \end{macrocode}
%
% \bigskip
% The following skip (=glue) is the vertical space inserted between two lines
% (=rows) of the |\halign|.
%    \begin{macrocode}
\skip_new:N \l_@@_interline_skip
%    \end{macrocode}
%
% \bigskip
% The following integer indicates the position of the box that will be created:
% 0 (=|t|=|\vtop|), 1~(=|c|=|\vcenter|) or 2 (=|b|=|\vbox|).
%    \begin{macrocode}
\int_new:N \l_@@_pos_env_int 
%    \end{macrocode}
%
% \bigskip
%    \begin{macrocode}
\dim_new:N \l_@@_xoffset_dim
\dim_set:Nn \l_@@_xoffset_dim { 3 mm }
%    \end{macrocode}
%
% 
% \bigskip
% The integer |\l_@@_pos_arrow_int| indicates the position of the arrow with the
% following code (the option |v| is accessible only for the arrows in
% |CodeAfter| where the options |i|, |group| et |groups| are not available).
%
% \begin{center}
% \begin{tabular}{l}
% \begin{tabular}{@{}l*8c@{}}
% \toprule
% option                 & |lr| & |ll| & |rl| & |rr| & |v| & |i| & |groups| & |group| \\
% \midrule
% |\l_@@_pos_arrow_int| & $0$  & $1$  & $2$  & $3$  & $4$ & $5$  & $6$  & $7$  \\
% \bottomrule
% \end{tabular} \\
% \footnotesize The option |v| can be used only in |\Arrow| in |CodeAfter| (see
% below). 
% \end{tabular}
% \end{center}
%
% 
%    \begin{macrocode}
\int_new:N \l_@@_pos_arrow_int
\int_set:Nn \l_@@_pos_arrow_int 3
%    \end{macrocode}
%
% \medskip
% The variable |\l_@@_input_line_str| will be used only to store, for each
% command |\Arrow| the line (in the TeX file) where the command is issued. This
% information will be stored in the field |input-line| of the arrow. As of now,
% This information is used only in the error message of a arrow impossible to
% draw because after the last row of the environment.
%    \begin{macrocode}
\str_new:N \l_@@_input_line_str
%    \end{macrocode}
%
% \bigskip
% The dimension |\l_@@_x_dim| will be used to compute the $x$-value for some
% vertical arrows when one of the options |i|, |group| and |groups| (values 5, 6
% and 7 of |\l_@@_pos_arrow_int|) is used.
%    \begin{macrocode}
\dim_new:N \l_@@_x_dim
%    \end{macrocode}
%
% \bigskip
% In the |\halign| of an environment |{WithArrows}| or |{DispWithArrows}|, we
% will have to use two counters:
% \begin{itemize}
% \item |\g_@@_arrow_int| to count the arrows created in the environment ;
% \item |\g_@@_line_int| to count the lines of the |\halign|.
% \end{itemize}
%
% These counters will be incremented in a cell of the |\halign| and, therefore,
% the incrementation must be global. However, we want to be able to include a
% |{WithArrows}| in another |{WithArrows}|. To do so, we must restore the
% previous value of these counters at the end of an environment |{WithArrows}|
% and we decide to manage a stack for each of these counters.
%    \begin{macrocode}
\seq_new:N \g_@@_arrow_int_seq
\int_new:N \g_@@_arrow_int
\seq_new:N \g_@@_line_int_seq
\int_new:N \g_@@_line_int
%    \end{macrocode}
%
%
%
% \bigskip
% The boolean |\l_@@_fleqn_bool| indicates wether the environments
% |{DispWithArrows}| must be composed flush left or centered. It corresponds to
% the option |fleqn|.
%    \begin{macrocode}
\bool_new:N \l_@@_fleqn_bool
%    \end{macrocode}
% 
% \bigskip
% The dimension |\l_@@_mathindent_dim| is used only by the environments
% |{DispWithArrows}|: it's the left margin of the environments
% |{DispWithArrows}| if the environment |{DispWithArrows}| is composed flush
% left (option |fleqn|).
%    \begin{macrocode}
\dim_new:N \l_@@_mathindent_dim
\dim_set:Nn \l_@@_mathindent_dim { 25 pt }
%    \end{macrocode}
% 
% \bigskip
% The boolean |\l_@@_wrap_lines_bool| corresponds to the option |wrap-lines|.
%    \begin{macrocode}
\bool_new:N \l_@@_wrap_lines_bool 
%    \end{macrocode}
%
% \bigskip
% For the environment |{DispWithArrows}|, the comma list |\l_@@_tags_clist| will
% be the list of the numbers of lines to be tagged (with the counter |equation|
% of LaTeX). In fact, |\l_@@_tags_clist| may contain non negative integers but
% also three special values, |first|, |last| and |all|.
%    \begin{macrocode}
\clist_new:N \l_@@_tags_clist
\clist_set:Nn \l_@@_tags_clist { all }
%    \end{macrocode}
% 
% \bigskip
% The token list |\l_@@_tag_tl| will contain the argument of the command |\tag|.
%    \begin{macrocode}
\tl_new:N \l_@@_tag_tl
%    \end{macrocode}
% 
% \bigskip
% The boolean |\l_@@_tag_star_bool| will be raised if the user uses the command
% |\tag| with a star.
%    \begin{macrocode}
\bool_new:N \l_@@_tag_star_bool
%    \end{macrocode}
%
% 
% \bigskip
% The boolean |\l_@@_in_first_column_bool| will be used to know wether we are in
% the first column of the environment |{WithArrows}| or |{DispWithArrows}|.
%    \begin{macrocode}
\bool_new:N \l_@@_in_first_column_bool
%    \end{macrocode}
%
% \bigskip
%    \begin{macrocode}
\bool_new:N \l_@@_initial_r_bool     
\bool_new:N \l_@@_initial_l_bool 
%    \end{macrocode}
%
% \bigskip
% The dimension |\l_@@_start_adjust_dim| and |\l_@@_end_adjust_dim| correspond
% to the options |start-adjust| and |end-adjust|.
%    \begin{macrocode}
\dim_new:N \l_@@_start_adjust_dim
\dim_set:Nn \l_@@_start_adjust_dim { 0.4 ex }
\dim_new:N \l_@@_end_adjust_dim
\dim_set:Nn \l_@@_end_adjust_dim { 0.4 ex }
%    \end{macrocode}
%
% \bigskip
% The parameter |\l_@@_status_arrow_str| will be used to store the ``status'' of
% an individual arrow. It will be used to fill the field ``status'' in the
% property list describing an arrow.
%    \begin{macrocode}
\str_new:N \l_@@_status_arrow_str
%    \end{macrocode}
%
% \bigskip
%    \begin{macrocode}
\str_set:Nn \l_@@_CommandName_str { Arrow }
%    \end{macrocode}
%
% \bigskip
% The string |\l_@@_string_Arrow_for_msg_str| is only a string that will be
% displayed in some error messages. For example, if |CommandName| is defined to
% be |Explanation|, the string |\l_@@_string_Arrow_for_msg_str| will contain
% ``|\Arrow alias \Explanation|''. 
%    \begin{macrocode}
\str_set:Nx \l_@@_string_Arrow_for_msg_str { \token_to_str:N \Arrow }
%    \end{macrocode}
%
%    \begin{macrocode}
\bool_new:N \l_@@_displaystyle_bool
\bool_new:N \l_@@_show_node_names_bool
%    \end{macrocode}
% 
% 
% 
% \bigskip
% \subsection{The definition of the options}
%
% There are four levels where options can be set:
% \begin{itemize}
% \item with |\usepackage[...]{witharrows}|: this level will be called
% \emph{package} level;
% \item with |\WithArrowsOptions{...}|: this level will be called \emph{global}
% level\footnote{This level is called \emph{global level} but the settings done
% by |\WithArrowsOptions| are local in the TeX sense: their scope corresponds to
% the current TeX group.};
% \item with |\begin{WithArrows}[...]|: this level will be called
% \emph{environment} level;
% \item with |\Arrow[...]| (included in |CodeAfter|): this level will be called
% \emph{local} level.
% \end{itemize}
%
%
% \bigskip
% When we scan a list of options, we want to be able to raise an error if two
% options of position of the arrows are present. That's why we keep 
% the first option of position in a variable called |\l_@@_previous_key_str|.
%
%    \begin{macrocode}
\cs_new_protected:Nn \@@_eval_if_allowed:n
  { 
    \str_if_empty:NTF \l_@@_previous_key_str
      { 
        \str_set_eq:NN \l_@@_previous_key_str \l_keys_key_tl
        #1
      }
      { \@@_error:n { Incompatible~options } }
  }
%    \end{macrocode}
%
%
%    \begin{macrocode}
\cs_new_protected:Nn \@@_fix_pos_option:n
  { \@@_eval_if_allowed:n { \int_set:Nn \l_@@_pos_arrow_int { #1 } } }
%    \end{macrocode}
%
% \bigskip
% First a set of keys that will be used at the global or environment level of
% options.
%    \begin{macrocode}
\keys_define:nn { WithArrows / Global }
  {
    ygap .dim_set:N = \l_@@_ygap_dim ,
    ygap .value_required:n = true ,
    ygap .initial:n = 0.4 ex ,
    ystart .dim_set:N = \l_@@_ystart_dim ,
    ystart .value_required:n = true ,
    ystart .initial:n = 0.4 ex ,
    more-columns .code:n = 
      \@@_msg_redirect_name:nn { Third~column~in~WithArrows } { none } ,
    more-columns .value_forbidden:n = true,
    CommandName .code:n =
      \str_set:Nn \l_@@_CommandName_str { #1 }
      \str_set:Nx \l_@@_string_Arrow_for_msg_str
        { \c_backslash_str Arrow~alias~\c_backslash_str #1 } ,
    CommandName .value_required:n = true ,
    TikzCode .tl_set:N = \l_@@_tikz_code_tl,
    TikzCode .initial:n = \draw~(#1)~to~node{#3}~(#2)~; ,
    TikzCode .value_required:n = true ,
    displaystyle .bool_set:N = \l_@@_displaystyle_bool ,
    displaystyle .default:n = true ,
    show-nodes .code:n =  
      \tikzset { @@_node_style / .append~style = { draw , red } } ,
    show-nodes .value_forbidden:n = true,
    show-node-names .bool_set:N = \l_@@_show_node_names_bool ,
    show-node-names .default:n = true ,
    group .code:n = 
      \str_if_empty:NTF \l_@@_previous_key_str
        {
          \str_set:Nn \l_@@_previous_key_str { group }
          \seq_remove_all:Nn \l_@@_options_Arrow_seq { xoffset }
          \int_set:Nn \l_@@_pos_arrow_int 7 
        }
        { \@@_error:n { Incompatible~options } } ,
    group .value_forbidden:n = true ,
    groups .code:n = 
      \str_if_empty:NTF \l_@@_previous_key_str
        { 
          \str_set:Nn \l_@@_previous_key_str { groups }
          \seq_if_in:NnF \l_@@_options_Arrow_seq { new-group }
            { \seq_put_right:Nn \l_@@_options_Arrow_seq { new-group } }
          \seq_remove_all:Nn \l_@@_options_Arrow_seq { xoffset }
          \int_set:Nn \l_@@_pos_arrow_int 6
        }
        { \@@_error:n { Incompatible~options } } ,
    groups .value_forbidden:n = true ,
    tikz   .code:n = \tikzset { WithArrows / arrow / .append~style = { #1 } } , 
    tikz   .initial:n         = \c_empty_tl ,
    tikz   .value_required:n  = true ,
    rr     .value_forbidden:n = true ,
    rr     .code:n            = \@@_fix_pos_option:n 3 ,
    ll     .value_forbidden:n = true ,
    ll     .code:n            = \@@_fix_pos_option:n 1 ,
    rl     .value_forbidden:n = true ,
    rl     .code:n            = \@@_fix_pos_option:n 2 ,
    lr     .value_forbidden:n = true ,
    lr     .code:n            = \@@_fix_pos_option:n 0 ,
    i      .value_forbidden:n = true ,
    i      .code:n            = \@@_fix_pos_option:n 5 ,
    xoffset .dim_set:N  = \l_@@_xoffset_dim ,
    xoffset .value_required:n  = true ,
    jot .dim_set:N = \jot ,
    jot .value_required:n = true ,
    interline .skip_set:N = \l_@@_interline_skip ,
    interline .value_required:n = true ,
    start-adjust .dim_set:N = \l_@@_start_adjust_dim ,
    start-adjust .value_required:n = true ,
    end-adjust .dim_set:N = \l_@@_end_adjust_dim ,
    end-adjust .value_required:n = true ,
    adjust .code:n  = 
      \dim_set:Nn \l_@@_start_adjust_dim { #1 }
      \dim_set:Nn \l_@@_end_adjust_dim { #1 } ,
    adjust .value_required:n = true
  }
%    \end{macrocode}
% 
% \bigskip
% Now a set of keys specific to the environments |{WithArrows}| (and not
% |{DispWithArrow}}|). Despite its name, this set of keys will also be used in
% |\WithArrowsOptions|. 
%    \begin{macrocode}
\keys_define:nn { WithArrows / WithArrowsSpecific }
  { 
    t   .code:n            = \int_set:Nn \l_@@_pos_env_int 0 ,
    t   .value_forbidden:n = true ,
    c   .code:n            = \int_set:Nn \l_@@_pos_env_int 1 ,
    c   .value_forbidden:n = true ,
    b   .code:n            = \int_set:Nn \l_@@_pos_env_int 2 ,
    b   .value_forbidden:n = true
  }
%    \end{macrocode}
%
% \bigskip
% Now a set of keys specific to the environments |{DispWithArrows}| and
% |{DispWithArrows*}| (and not |{WithArrows}|). Despite its name, this set of
% keys will also be used in |\WithArrowsOptions|. 
%    \begin{macrocode}
\keys_define:nn { WithArrows / DispWithArrowsSpecific }
  {  
    fleqn .bool_set:N = \l_@@_fleqn_bool ,
    fleqn .default:n = true ,
    mathindent .dim_set:N = \l_@@_mathindent_dim ,
    mathindent .value_required:n = true ,
    notag .code:n = 
      \str_if_eq:nnTF { #1 } { true }
        { \clist_clear:N \l_@@_tags_clist }
        { \clist_set:Nn \l_@@_tags_clist { all } } ,
    notag .default:n = true ,
    nonumber .meta:n = notag ,
    allow-multiple-labels .code:n = 
      \@@_msg_redirect_name:nn { Multiple~labels } { none } ,
    allow-multiple-labels .value_forbidden:n = true ,
    wrap-lines .bool_set:N = \l_@@_wrap_lines_bool ,
    wrap-lines .default:n = true ,
    tagged-lines .code:n =   
      \clist_set:Nn \l_@@_tags_clist { #1 }
      \clist_if_in:NnT \l_@@_tags_clist { first }
        {
          \clist_remove_all:Nn \l_@@_tags_clist { first }
          \clist_put_left:Nn \l_@@_tags_clist \c_one_int
        } ,
    tagged-lines .value_required:n = true 
  }
%    \end{macrocode}
%
%
% \bigskip
% Now, we begin the construction of the set of keys that will be used in the
% environments |{WithArrows}|.
%    \begin{macrocode}
\keys_define:nn { WithArrows } 
  { 
    WithArrows .inherit:n = 
      { 
        WithArrows / Global , 
        WithArrows / WithArrowsSpecific 
      }
  }
%    \end{macrocode}
% 
% \medskip
%    \begin{macrocode}
\keys_define:nn { WithArrows / WithArrows } 
 { 
   name .tl_set:N = \l_@@_name_str ,
   name .value_required:n = true ,
   CodeBefore .code:n = \tl_put_right:Nn \l_@@_code_before_tl { #1 } ,
   CodeBefore .value_required:n = true,
   CodeAfter .code:n = \tl_put_right:Nn \l_@@_code_after_tl { #1 } ,
   CodeAfter .value_required:n = true ,
   unknown .code:n  = 
     \@@_sort_seq:N \l_@@_options_WithArrows_seq 
     \@@_error:n { Unknown~option~WithArrows } 
 }
%    \end{macrocode}
% 
% \bigskip
% A sequence of the options available in |{WithArrows}|. This sequence will be
% used in the error messages and can be modified dynamically.
%    \begin{macrocode}
\seq_set_from_clist:Nn \l_@@_options_WithArrows_seq
  { 
    adjust, b, c, CodeAfter, CodeBefore, CommandName, displaystyle, end-adjust,
    group, groups, i, interline, jot, ll, lr, more-columns, name, rl, rr,
    show-node-names, show-nodes, start-adjust, t, tikz, TikzCode, xoffset, ygap,
    ystart
  } 
%    \end{macrocode}
%
% \bigskip
% Now, we construct the keys set which will be used in the environments
% |{DispWithArrows}| and |{DispWithArrows*}|.
%    \begin{macrocode}
\keys_define:nn { WithArrows } 
  { 
    DispWithArrows .inherit:n = 
     { 
       WithArrows / DispWithArrowsSpecific , 
       WithArrows / Global 
     } 
  }
%    \end{macrocode}
%
% \bigskip
%    \begin{macrocode}
\keys_define:nn { WithArrows / DispWithArrows } 
  { 
    name .tl_set:N = \l_@@_name_str ,
    name .value_required:n = true ,
    CodeBefore .code:n = \tl_put_right:Nn \l_@@_code_before_tl { #1 } ,
    CodeBefore .value_required:n = true ,
    CodeAfter .code:n  =  \tl_put_right:Nn \l_@@_code_after_tl { #1 } ,
    CodeAfter .value_required:n = true ,
    unknown .code:n  = 
      \@@_sort_seq:N \l_@@_options_DispWithArrows_seq
      \@@_error:n { Unknown~option~DispWithArrows } 
  }
%    \end{macrocode}
%
% \bigskip
% A sequence of the options available in |{DispWithArrows}|. This sequence will
% be used in the error messages and can be modified dynamically.
%    \begin{macrocode}
\seq_set_from_clist:Nn \l_@@_options_DispWithArrows_seq
  { 
    allow-multiple-labels, CodeAfter, CodeBefore, CommandName, TikzCode, adjust,
    displaystyle, end-adjust, fleqn, group, groups, i, interline, jot, ll, lr, 
    mathindent, name, nonumber, notag, rl, rr, show-node-names, show-nodes, 
    start-adjust, tagged-lines, tikz, wrap-lines, xoffset, ygap, ystart 
  }
%    \end{macrocode}
% 
% \bigskip
% Now, we construct the keys set which will be used with the command |\WithArrowsOptions|.
%    \begin{macrocode}
\keys_define:nn { WithArrows } 
  { 
    WithArrowsOptions .inherit:n = 
     { 
       WithArrows / Global , 
       WithArrows / WithArrowsSpecific , 
       WithArrows / DispWithArrowsSpecific 
     } 
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\keys_define:nn { WithArrows / WithArrowsOptions } 
  { 
    unknown .code:n  = 
      \@@_sort_seq:N \l_@@_options_WithArrowsOptions_seq
      \@@_error:n { Unknown~option~WithArrowsOptions } 
  }
%    \end{macrocode}
% 
%
% \bigskip
% A sequence of the options available in |\WithArrowsOptions|. This sequence
% will be used in the error messages and can be modified dynamically.
%    \begin{macrocode}
\seq_set_from_clist:Nn \l_@@_options_WithArrowsOptions_seq
  { 
    allow-multiple-labels, b, c, CommandName, more-columns, TikzCode, adjust, 
    displaystyle, end-adjust, fleqn, group, groups, i, interline, jot, ll, lr, 
    mathindent, nonumber, notag, rl, rr, show-node-names, show-nodes, 
    start-adjust, t, tagged-lines, tikz, wrap-lines, xoffset, ygap, ystart
  }
%    \end{macrocode}
% 
% \bigskip
% The command |\@@_set_independent:| is a command without argument that will be
% used to specifiy that the arrow will be ``independent'' (of the potential
% groups of the option |group| or |groups|). This information will be stored in
% the field ``status'' of the arrow. Another value of the field ``status'' is
% ``new-group''.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_set_independent:
  { 
    \str_if_empty:NTF \l_@@_previous_key_str
      {
        \str_set_eq:NN \l_@@_previous_key_str \l_keys_key_tl
        \str_set:Nn \l_@@_status_arrow_str { independent } 
        \str_if_eq:VnF \l_keys_value_tl { NoValue } 
          { \@@_error:n { Value~for~a~key } }
      }
      { \@@_error:n { Incompatible~options~in~Arrow } }
  }
%    \end{macrocode}
%
% \bigskip
% The options of an individual arrow are parsed twice. The first pass is when
% the command |\Arrow| is read. The second pass is when the arrows are drawn
% (after the end of the environment |{WithArrows}| or |{DispWithArrows}|). Now,
% we present the keys set for the first pass. The main goal is to extract
% informations which will be necessary during the scan of the arrows. For
% instance, we have to known if some arrows are ``independent'' or use the
% option ``new-group''.
%    \begin{macrocode}
\keys_define:nn { WithArrows / Arrow / FirstPass }
  { 
    jump .code:n = 
      \int_compare:nTF { #1 > 0 }
        { \int_set:Nn \l_@@_jump_int { #1 } }
        { \@@_error:n { Negative~jump } } ,
    jump .value_required:n  = true,
    rr .code:n = \@@_set_independent: ,
    ll .code:n = \@@_set_independent: ,
    rl .code:n = \@@_set_independent: ,
    lr .code:n = \@@_set_independent: ,
    i  .code:n = \@@_set_independent: ,
    rr .default:n = NoValue ,
    ll .default:n = NoValue ,
    rl .default:n = NoValue ,
    lr .default:n = NoValue ,
    i  .default:n = NoValue ,
    new-group .value_forbidden:n = true,
    new-group .code:n = 
      \int_compare:nTF { \l_@@_pos_arrow_int = 6 }
        { \str_set:Nn \l_@@_status_arrow_str { new-group } }
        { \@@_error:n { new-group~without~groups } } , 
%    \end{macrocode}
%
% \medskip
% The other keys don't give any information necessary during the scan of the
% arrows. However, you try to detect errors and that's why all the keys are
% listed in this keys set. An unknown key will be detected at the point of the
% command |\Arrow| and not at the end of the environment.
%    \begin{macrocode}
    TikzCode .code:n = \prg_do_nothing: ,
    TikzCode .value_required:n = true ,
    tikz .code:n = \prg_do_nothing: ,
    tikz .value_required:n = true ,
%    \end{macrocode}
%
% \medskip
% The option |xoffset| is not allowed when the option |group| or the option
% |groups| is used (since it would be meaningless).
%    \begin{macrocode}
    xoffset .code:n = 
      \int_compare:nNnT \l_@@_pos_arrow_int > 5
        { \@@_error:n { Option~xoffset~forbidden } } ,
    xoffset .value_required:n = true ,
    start-adjust .code:n = \prg_do_nothing: ,
    start-adjust .value_required:n = true ,
    end-adjust .code:n = \prg_do_nothing: ,
    end-adjust .value_required:n = true ,
    adjust .code:n  = \prg_do_nothing: ,
    adjust .value_required:n = true ,
    unknown .code:n = 
      \@@_sort_seq:N \l_@@_options_Arrow_seq
      \@@_error:n { Unknown~option~in~Arrow }
  }
%    \end{macrocode}
%
%
% \bigskip
% A sequence of the options available in |\Arrow|. This sequence will be used in
% the error messages and can be modified dynamically.
%    \begin{macrocode}
\seq_set_from_clist:Nn \l_@@_options_Arrow_seq
  { 
    adjust, end-adjust, i, jump, ll, lr, rl, rr, start-adjust, tikz, TikzCode,
    xoffset 
  }
%    \end{macrocode}
%
% \bigskip
%    \begin{macrocode}
\cs_new_protected:Nn \@@_fix_pos_arrow:n
  { 
    \str_if_empty:NT \l_@@_previous_key_str
      { 
        \str_set_eq:NN \l_@@_previous_key_str \l_keys_key_tl
        \int_set:Nn \l_@@_pos_arrow_int { #1 } 
      }
  }
%    \end{macrocode}
%
% \bigskip
% The options of the individual commands |\Arrows| are scanned twice. The second
% pass is just before the drawing of the arrow. In this set of keys, we don't put
% an item for the unknown keys because an unknown key would have been already
% detected during the first pass.
%
%    \begin{macrocode} 
\keys_define:nn {WithArrows / Arrow / SecondPass }
  { 
    TikzCode .tl_set:N = \l_@@_tikz_code_tl ,
    TikzCode .initial:n = \draw~(#1)~to~node{#3}~(#2)~; ,
    tikz .code:n = \tikzset { WithArrows / arrow / .append~style = { #1 } } ,
    tikz .initial:n = \c_empty_tl ,
    rr .code:n = \@@_fix_pos_arrow:n 3 ,
    ll .code:n = \@@_fix_pos_arrow:n 1 ,
    rl .code:n = \@@_fix_pos_arrow:n 2 ,
    lr .code:n = \@@_fix_pos_arrow:n 0 ,
    i  .code:n = \@@_fix_pos_arrow:n 5 ,
%    \end{macrocode}
%
% \medskip
% The option |xoffset| is not allowed when the option |group| or the option 
% |groups| is used (since it would be meaningless). An error has been raised 
% during the first pass. Here, we manage to avoid a second error which
% would be redundant.
%    \begin{macrocode}
    xoffset .code:n  = 
      \int_compare:nNnF \l_@@_pos_arrow_int > 5
        { \dim_set:Nn \l_@@_xoffset_dim { #1 } } ,
    start-adjust .dim_set:N = \l_@@_start_adjust_dim,
    end-adjust .dim_set:N = \l_@@_end_adjust_dim,
    adjust .code:n  =  
      \dim_set:Nn \l_@@_start_adjust_dim { #1 }
      \dim_set:Nn \l_@@_end_adjust_dim { #1 } ,
  }
%    \end{macrocode}
% 
% \bigskip
% |\WithArrowsOptions| is the command of the \pkg{witharrows} package to fix
% options at the document level. It's possible to fix in |\WithArrowsOptions|
% some options specific to |{WithArrows}| (in contrast with |{DispWithArrows}|)
% or specific to |{DispWithArrows}| (in construct with |{WithArrows}|). That's
% why we have constructed a set of keys specific to |\WithArrowsOptions|.
%    \begin{macrocode}
\NewDocumentCommand \WithArrowsOptions { m }
  { 
    \str_clear_new:N \l_@@_previous_key_str
    \keys_set:nn { WithArrows / WithArrowsOptions } { #1 } 
  }
%    \end{macrocode}
%
% 
% \bigskip
% \subsection{The command Arrow}
%
% In fact, the internal command is not named |\Arrow| but |\@@_Arrow|. Usually,
% at the beginning of an environment |{WithArrows}|, |\Arrow| is set to be
% equivalent to |\@@_Arrow|. However, the user can change the name with the
% option |CommandName| and the user command for |\@@_Arrow| will be different.
% This mechanism can be useful when the user has already a command named
% |\Arrow| he still wants to use in the environments |{WithArrows}| or
% |{DispWithArrows}|. 
%
% \medskip
%    \begin{macrocode}
\NewDocumentCommand \@@_Arrow { O { } m ! O { } }
  {
%    \end{macrocode}
%
% The counter |\g_@@_arrow_int| counts the arrows in the environment. The
% incrementation must be global (|gincr|) because the command |\Arrow| will be
% used in the cell of a |\halign|. It's recalled that we manage a stack for this
% counter.
%    \begin{macrocode}
    \int_gincr:N \g_@@_arrow_int
%    \end{macrocode}
% 
% \medskip
% We will construct a global property list to store the informations of the
% considered arrow. The six fields of this property list are ``initial'',
% ``final'', ``status'', ``options'', ``label'' and ``input-line''. In order to
% compute the value of ``final'' (the destination row of the arrow), we have to
% take into account a potential option |jump|. In order to compute the value of
% the field ``status'', we have to take into account options as |ll|, |rl|,
% |rr|, |lr|, etc. or |new-group|.
% 
% We will do that job with a first analyze of the options of the command
% |\Arrow| with a dedicated set of keys called |WithArrows/Arrow/FirstPass|.
% 
%    \begin{macrocode}
    \str_clear_new:N \l_@@_previous_key_str
    \keys_set:nn { WithArrows / Arrow / FirstPass } { #1 , #3 } 
%    \end{macrocode}
%
% \medskip
% We construct now a global property list to store the informations of the
% considered arrow with the six fields ``initial'', ``final'', ``status'',
% ``options'', ``label'' and ``input-line''.
%
% \smallskip
% \begin{enumerate}
% \item First, the row from which the arrow starts:
%    \begin{macrocode}
    \prop_put:NnV \l_tmpa_prop { initial } \g_@@_line_int
%    \end{macrocode}
%
% \item The row where the arrow ends (that's why it was necessary to analyze the
% key |jump|):
%    \begin{macrocode}
    \int_set:Nn \l_tmpa_int { \g_@@_line_int + \l_@@_jump_int }
    \prop_put:NnV \l_tmpa_prop { final } \l_tmpa_int
%    \end{macrocode}
%
% \item The ``status'' of the arrow, with 3 possible values: empty,
% |independent|, or |new-group|.
%    \begin{macrocode} 
    \prop_put:NnV \l_tmpa_prop { status } \l_@@_status_arrow_str
%    \end{macrocode}
% 
% \item The options of the arrow (it's a token list):
%    \begin{macrocode}
    \prop_put:Nnn \l_tmpa_prop { options } { #1 , #3 }
%    \end{macrocode}
%
% \item The label of the arrow (it's also a token list):
%    \begin{macrocode}
    \prop_put:Nnn \l_tmpa_prop { label } { #2 }
%    \end{macrocode}
% 
% \item The number of the line where the command |\Arrow| is issued in the TeX
% source (as of now, this is only useful for an error message).
%    \begin{macrocode}
    \prop_put:Nnx \l_tmpa_prop { input-line } \msg_line_number:
%    \end{macrocode}
% \end{enumerate}
%
% The property list has been created in a local variable for convenience. Now,
% it will be stored in a global variable indicating both the
% position-in-the-tree and the number of the arrow.
% 
%    \begin{macrocode}
    \prop_gclear_new:c 
      { g_@@_arrow _ \l_@@_prefix_str _ \int_use:N \g_@@_arrow_int _ prop }
    \prop_gset_eq:cN 
      { g_@@_arrow _ \l_@@_prefix_str _ \int_use:N \g_@@_arrow_int _ prop } 
      \l_tmpa_prop
  }       
%    \end{macrocode}
%
% \medskip
%    \begin{macrocode}
\cs_new_protected:Nn \@@_Arrow_first_column: 
  { \@@_error:n { Arrow~in~first~column } \@@_Arrow }
%    \end{macrocode}
%                                
%
% \bigskip
% \subsection{The environment \{WithArrows\}}
%
% The command |\@@_pre_environement:| is a code common to the environments
% |{WithArrows}| and |{DispWithArrows}|. The argument is the list of options
% given to the environment.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_pre_environment:n
%    \end{macrocode}
%
% First the initialisation of |\l_@@_type_env_str| which is the name of the
% encompassing environment. In fact, this token list is used only in the error
% messages.
%    \begin{macrocode}
  { 
    \str_clear_new:N \l_@@_type_env_str
    \str_set:NV \l_@@_type_env_str \@currenvir
%    \end{macrocode}
%
% \bigskip
% We deactivate the potential externalization of Tikz. The Tikz elements created
% by \pkg{witharrows} can't be externalized since they are created in Tikz
% pictures with |overlay| and |remember picture|.
%    \begin{macrocode}
    \cs_if_exist:NT \tikz@library@external@loaded
      { \tikzset { external / export = false } }
%    \end{macrocode}
%
% \bigskip
% The token list |\l_@@_name_str| will contain the potential name of the
% environment (given with the option |name|). This name will be used to create
% aliases for the names of the nodes.
%    \begin{macrocode}
    \str_clear_new:N \l_@@_name_str
%    \end{macrocode}
% 
% The initialisation of the counters |\g_@@_arrow_int| and |\g_@@_line_int|.
% However, we have to save their previous values with the two stacks created for
% this end.
%    \begin{macrocode}
    \seq_gput_right:NV \g_@@_arrow_int_seq \g_@@_arrow_int
    \int_gzero:N \g_@@_arrow_int 
    \seq_gput_right:NV \g_@@_line_int_seq \g_@@_line_int
    \int_gzero:N \g_@@_line_int 
%    \end{macrocode}
% 
% \bigskip
% We also have to update the position on the nesting tree.
%    \begin{macrocode}
    \seq_gput_right:Nn \g_@@_position_in_the_tree_seq 1
%    \end{macrocode}
%
% The nesting tree is used to create a prefix which will be used in the names of
% the Tikz nodes and in the names of the arrows (each arrow is a property list
% of six fields). If we are in the second environment |{WithArrows}| nested in
% the third environment |{WithArrows}| of the document, the prefix will be |3-2|
% (although the position in the tree is $[3,2,1]$ since such a position always
% ends with a~$1$). First, we do a copy of the position-in-the-tree and then we
% pop the last element of this copy (in order to drop the last~$1$).
%    \begin{macrocode}
    \seq_set_eq:NN \l_tmpa_seq \g_@@_position_in_the_tree_seq
    \seq_pop_right:NN \l_tmpa_seq \l_tmpa_tl
    \str_clear_new:N \l_@@_prefix_str
    \str_set:Nx \l_@@_prefix_str { \seq_use:Nnnn \l_tmpa_seq - - - }
%    \end{macrocode}
% 
% \bigskip
% We define the command |\\| to be the command |\@@_cr:| (defined below). 
%    \begin{macrocode}
    \cs_set_eq:NN \\ \@@_cr:
    \dim_zero:N \mathsurround 
%    \end{macrocode}
%
% \bigskip
% These counters will be used later as variables.
%    \begin{macrocode}
    \int_zero_new:N \l_@@_initial_int
    \int_zero_new:N \l_@@_final_int
    \int_zero_new:N \l_@@_arrow_int
    \int_zero_new:N \l_@@_pos_of_arrow_int
    \int_zero_new:N \l_@@_jump_int
    \int_set:Nn \l_@@_jump_int \c_one_int
%    \end{macrocode}
%
% \bigskip
% In (the second column of) |{DispWithArrows}|, it's possible to put several
% labels (for the same number of equation). That's why these labels will be
% stored in a sequence |\l_@@_labels_seq|.
%    \begin{macrocode}
    \seq_clear_new:N \l_@@_labels_seq
%    \end{macrocode}
%
%    \begin{macrocode}
    \@@_bool_new:N \l_@@_tag_next_line_bool
%    \end{macrocode}
% 
% \bigskip
% The value corresponding to the key |interline| is put to zero before the
% treatment of the options of the environment.\footnote{It's recalled that, by
% design, the option |interline| of an environment doesn't apply in the nested
% environments.}
%    \begin{macrocode}
    \skip_zero:N \l_@@_interline_skip
%    \end{macrocode}
%
% \bigskip
% The value corresponding to the key |CodeBefore| is put to nil before the
% treatment of the options of the environment, because, of course, we don't want
% the code executed at the beginning of all the nested
% environments~|{WithArrows}|. Idem for |CodeAfter|. 
%    \begin{macrocode}
    \tl_clear_new:N \l_@@_code_before_tl
    \tl_clear_new:N \l_@@_code_after_tl
%    \end{macrocode}
%
% \bigskip
% We process the options given to the environment |{WithArrows}| or |{DispWithArrows}|. 
%    \begin{macrocode}
    \str_clear_new:N \l_@@_previous_key_str 
    \bool_if:NT \l_@@_in_WithArrows_bool
      { \keys_set:nn { WithArrows / WithArrows } { #1 } }
    \bool_if:NT \l_@@_in_DispWithArrows_bool
      { \keys_set:nn { WithArrows / DispWithArrows } { #1 } }
%    \end{macrocode}
%
% \bigskip
% If the option |footnote| or the option |footnotehyper| is used, then we
% extract the footnotes with a environment |{savenotes}| (of the package
% \pkg{footnote} or the package \pkg{footnotehyper}).
%    \begin{macrocode}
    \bool_if:NT \g_@@_footnote_bool { \begin { savenotes } }
%    \end{macrocode}
%
% \bigskip
% We execute the code |\l_@@_code_before_tl| of the option |CodeBefore| of the
% environment after the eventual |\savenotes| and, symetrically, we will execute
% the |\l_@@_code_after_tl| before the eventual |\endsavenotes| (we have a good
% reason for the last point: we want to extract the footnotes of the arrows
% executed in the |CodeAfter|).
%    \begin{macrocode}
    \l_@@_code_before_tl
%    \end{macrocode}
%
% \bigskip
% If the user has given a value for the option |CommandName| (at the global or
% at the \emph{environment} level), a command with this name is defined locally
% in the environment with meaning |\@@_Arrow|. The default value of the option
% |CommandName| is ``|Arrow|'' and thus, by default, the name of the command
% will be |\Arrow|.
%    \begin{macrocode}
    \cs_set_eq:cN \l_@@_CommandName_str \@@_Arrow
  }
%    \end{macrocode}
% This is the end of |\@@_pre_environment:n|.
%
%
% \bigskip
% Now, we begin the environment |{WithArrows}|.
%    \begin{macrocode}
\NewDocumentEnvironment { WithArrows } { ! O { } }
  { 
    \bool_set_true:N \l_@@_in_WithArrows_bool
    \bool_set_false:N \l_@@_in_DispWithArrows_bool
    \@@_pre_environment:n { #1 } 
    \if_mode_math: \else:
      \@@_error:n { WithArrows~outside~math~mode }
    \fi:
    \cs_set_eq:NN \notag \@@_notag:
    \cs_set_eq:NN \nonumber \@@_notag:
    \cs_set_eq:NN \tag \@@_tag
    \cs_set_eq:NN \label \@@_label:n
    \cs_set_eq:NN \tagnextline \@@_tagnextline:
%    \end{macrocode}
% \bigskip 
% The environment begins with a |\vtop|, a |\vcenter| or a
% |\vbox|\footnote{Notice that the use of |\vtop| seems color-safe here...}
% depending of the value of |\l_@@_pos_env_int| (fixed by the options |t|, |c|
% or |b|). The environment |{WithArrows}| must be used in math mode\footnote{An
% error is raised if the environment is used outside math mode.} and therefore,
% we can use |\vcenter|.
%    \begin{macrocode}
    \int_case:nn \l_@@_pos_env_int { 0 \vtop 1 \vcenter 2 \vbox }
    \bgroup
%    \end{macrocode}
%
% \bigskip
% The command |\spread@equation| is the command used by \pkg{amsmath} in the
% beginning of an alignment to fix the interline. When used, it becomes no-op.
% However, it's possible to use \pkg{witharrows} without \pkg{amsmath} since we
% have redefined |\spread@equation| (if it is not defined yet).
%    \begin{macrocode}
    \spread@equation
%    \end{macrocode}
%
% \bigskip
% We begin the |\halign| and the preamble.
%    \begin{macrocode}
    \ialign \bgroup
%    \end{macrocode}
%
% \bigskip 
% We increment the counter |\g_@@_line_int| which will be used in the names of
% the Tikz nodes created in the array. This incrementation must be global
% (|gincr|) because we are in the cell of a |\halign|. It's recalled that we
% manage a stack for this counter.
%    \begin{macrocode}
    \int_gincr:N \g_@@_line_int 
    \cs_set_eq:cN \l_@@_CommandName_str \@@_Arrow_first_column: 
    \bool_set_true:N \l_@@_in_first_column_bool
    \strut \hfil
    $ 
    \bool_if:NT \l_@@_displaystyle_bool \displaystyle 
    { ## } 
    $
    & 
%    \end{macrocode}
% 
% \bigskip
%    \begin{macrocode}
    $ 
    \bool_if:NT \l_@@_displaystyle_bool \displaystyle 
    { { } ## } 
    $
%    \end{macrocode}
%
% \bigskip
% We create the ``left node'' of the line (when using macros in Tikz node names,
% the macros have to be fully expandable: here, |\int_use:N| is fully
% expandable).
%    \begin{macrocode}
    \tikz [ remember~picture , overlay ] 
      \node 
        [ 
          node~contents = { } ,
          @@_node_style ,
          name = wa - \l_@@_prefix_str - \int_use:N \g_@@_line_int - l ,
          alias = 
            { 
              \str_if_empty:NF \l_@@_name_str
                { \l_@@_name_str - \int_use:N \g_@@_line_int - l }
            } 
        ] 
        ;
    \hfil
%    \end{macrocode}
%
% \bigskip
% Now, after the |\hfil|, we create the ``right node'' and, if the option
% |show-node-names| is raised, the name of the node is written in the document
% (useful for debugging).
%    \begin{macrocode}
    \tikz [ remember~picture , overlay ] 
      \node 
        [ 
          node~contents = { } ,
          @@_node_style ,
          name = wa - \l_@@_prefix_str - \int_use:N \g_@@_line_int - r ,
          alias = 
            {
              \str_if_empty:NF \l_@@_name_str
                { \l_@@_name_str - \int_use:N \g_@@_line_int - r }
            } 
        ] 
        ;
    \bool_if:NT \l_@@_show_node_names_bool
      { 
        \hbox_overlap_right:n 
          { \small wa - \l_@@_prefix_str - \int_use:N \g_@@_line_int }
      }
%    \end{macrocode}
% 
% \bigskip
% Usually, the |\halign| of an environment |{WithArrows}| will have exactly two
% columns. Nevertheless, if the user wants to use more columns (without arrows)
% it's possible with the option |more-columns|.
%    \begin{macrocode}
    && 
    \@@_error:n { Third~column~in~WithArrows }
    $ 
    \bool_if:NT \l_@@_displaystyle_bool \displaystyle 
    { ## } 
    $
    \cr
  }
%    \end{macrocode}
%
% \bigskip 
% We begin the second part of the environment |{WithArrows}|. We have two
% |\egroup|\,: one for the |\halign| and one for the |\vtop| (or |\vcenter| or
% |\vbox|).
%    \begin{macrocode}
  {
    \\
    \egroup 
    \egroup
    \@@_post_environment:
%    \end{macrocode}
%
% \bigskip
% If the option |footnote| or the option |footnotehyper| is used, then we
% extract the footnotes with an environment |{footnote}| (of the package
% \pkg{footnote} or the package \pkg{footnotehyper}).
%    \begin{macrocode}
    \bool_if:NT \g_@@_footnote_bool { \end { savenotes } }
  }
%    \end{macrocode}
% This is the end of the environment |{WithArrows}|.
% 
%
% \bigskip
% The command |\@@_post_environment:| is a code common to the second part of the
% environment |{WithArrows}| and the environment |{DispWithArrows}|.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_post_environment:
%    \end{macrocode}
%
% \bigskip
% The command |\WithArrowsRightX| is not used by \pkg{witharrows}. It's only a
% convenience given to the user.
%    \begin{macrocode}
  { 
    \cs_set:Npn \WithArrowsRightX { \g_@@_right_x_dim }  
%    \end{macrocode}
%
% \bigskip 
% It there is really arrows in the environment, we draw the arrows.
%    \begin{macrocode}
    \int_compare:nNnT \g_@@_arrow_int > 0 \@@_scan_arrows:
%    \end{macrocode}
%
% \bigskip
% We will execute the code specified in the option |CodeAfter|, after some
% settings. 
%    \begin{macrocode}
    \group_begin:
      \tikzset { every~picture / .style = @@_standard }
%    \end{macrocode}
% The command |\WithArrowsNbLines| is not used by \pkg{witharrows}. It's only a
% convenience given to the user.  
%    \begin{macrocode}
      \cs_set:Npn \WithArrowsNbLines { \int_use:N \g_@@_line_int }
%    \end{macrocode}
% The command |\MultiArrow| is available in |CodeAfter|, and we have a special
% version of |\Arrow|, called ``|\Arrow| in |CodeAfter|'' in the
% documentation.\footnote{As for now, |\MultiArrow| has no option, and that's
% why its internal name is a name of \pkg{expl3} with the signature |:nn|
% whereas |\Arrow| in |CodeAfter| provides options and has the name of a
% function defined with |\NewDocumentCommand|.}
%    \begin{macrocode}
      \cs_set_eq:NN \MultiArrow \@@_MultiArrow:nn
      \cs_set_eq:cN \l_@@_CommandName_str \@@_Arrow_code_after
      \bool_set_true:N \l_@@_in_CodeAfter_bool
      \l_@@_code_after_tl
    \group_end:
%    \end{macrocode}
%
% \bigskip
% We update the position-in-the-tree. First, we drop the last component and then
% we increment the last element.
%    \begin{macrocode}
    \seq_gpop_right:NN \g_@@_position_in_the_tree_seq \l_tmpa_tl
    \seq_gpop_right:NN \g_@@_position_in_the_tree_seq \l_tmpa_tl
    \seq_gput_right:Nx \g_@@_position_in_the_tree_seq 
      { \int_eval:n { \l_tmpa_tl + 1 } }
%    \end{macrocode}
%
% \bigskip
% We update the value of the counter |\g_@@_last_env_int|. This counter is used
% only by the user function |\WithArrowsLastEnv|.
%    \begin{macrocode}
    \int_compare:nNnT { \seq_count:N \g_@@_position_in_the_tree_seq } = 1
      { \int_gincr:N \g_@@_last_env_int }
%    \end{macrocode}
%
% \bigskip
% Finally, we restore the previous values of the counters |\g_@@_arrow_int| and
% |\g_@@_line_int| It is recalled that we manage three stacks in order to be
% able to do such a restoration.
%    \begin{macrocode}
    \seq_gpop_right:NN \g_@@_arrow_int_seq \l_tmpa_tl 
    \int_gset:Nn \g_@@_arrow_int \l_tmpa_tl 
    \seq_gpop_right:NN \g_@@_line_int_seq \l_tmpa_tl
    \int_gset:Nn \g_@@_line_int \l_tmpa_tl
  }
%    \end{macrocode}
% That's the end of the command |\@@_post_environment:|.
%
% \bigskip
% We give now the definition of |\@@_cr:| which is the definition of |\\| in an
% environment |{WithArrows}|. The two \pkg{expl3} commands
% |\group_align_safe_begin:| and |\group_align_safe_end:| are specifically
% designed for this purpose: test the token that follows in a |\halign|
% structure.
%
% First, we remove an eventual token |*| since the commands |\\| and |\\*| are
% equivalent in an environment |{WithArrows}| (an environment |{WithArrows}|,
% like an environment |{aligned}| of \pkg{amsmath}, is always unbreakable).
%    \begin{macrocode}
\cs_new_protected:Nn \@@_cr:
  { 
    \scan_stop:
    \bool_if:NT \l_@@_in_first_column_bool { & { } } 
    \group_align_safe_begin:
    \peek_meaning_remove:NTF * \@@_cr_i: \@@_cr_i:
  }
%    \end{macrocode}
%
% \medskip
% Then, we peek the next token to see if it's a |[|. In this case, the command
% |\\| has an optional argument which is the vertical skip (=glue) to put.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_cr_i:
  { \peek_meaning:NTF [ \@@_cr_ii: { \@@_cr_ii: [ \c_zero_dim ] } }
%    \end{macrocode}
% 
% \bigskip
%    \begin{macrocode}
\cs_new_protected:Npn \@@_cr_ii: [ #1 ]
  { 
    \group_align_safe_end:
%    \end{macrocode}
% For the environment |{DispWithArrows}|, the behaviour of |\\| is different
% because we add the third column which is the column for the tag (number of the
% equation). Even if there is no tag, the third column is used for the
% |v|-nodes.
%    \begin{macrocode}
    \bool_if:NT \l_@@_in_DispWithArrows_bool
%    \end{macrocode}
% At this stage, we know that we have a tag to put if (and only if) the value of
% |\l_@@_tags_clist| is the comma list |all| (only one element). Maybe,
% previously, the value of |\l_@@_tags_clist| was, for example, |1,last| (which
% means that only the first line and the last line must be tagged). However, in
% this case, the comparison with the number of line has be done before and, now,
% if we are in a line to tag, the value of |\l_@@_tags_clist| is |all|.
%    \begin{macrocode}
      { 
        \clist_if_in:NnTF \l_@@_tags_clist { all }
          {
%    \end{macrocode}
% Here, we can't use |\refstepcounter{equation}| because if the user has issued
% a |\tag| command, we have to use |\l_@@_tag_tl| and not |\theequation|. That's
% why we have to do the job done by |\refstepcounter| manually.
% 
% First, the incrementation of the counter (potentially).
%    \begin{macrocode}
            \tl_if_empty:NT \l_@@_tag_tl { \int_gincr:N \c@equation }
%    \end{macrocode}
% 
% We store in |\g_tmpa_tl| the tag we will have to compose at the end of the
% line. We use a global variable because we will use it in the \emph{next} cell
% (after the |&|).
%    \begin{macrocode}
            \cs_gset:Npx \g_tmpa_tl
              { \tl_if_empty:NTF \l_@@_tag_tl \theequation \l_@@_tag_tl }
%    \end{macrocode}
% It's possible to put several labels for the same line (it's not possible in
% the environments of \pkg{amsmath}). That's why the differents labels of a same
% line are stored in a sequence |\l_@@_labels_seq|.
%    \begin{macrocode}
            \seq_if_empty:NF \l_@@_labels_seq
              {
%    \end{macrocode}
% Now, we do the job done by |\refstepcounter| and by the redefinitions of
% |\refstepcounter| done by some packages (the incrementation of the counter has
% been done yet).
%
% First an action which is in the definition of |\refstepcounter|. The command
% |\p@equation| is redefined by some extensions like \pkg{fncylab}.
%    \begin{macrocode}
                \cs_set:Npx \@currentlabel { \p@equation \g_tmpa_tl }
%    \end{macrocode}
% Then, an action done by \pkg{hyperref} in its redefinition of
% |\refstepcounter|.
%    \begin{macrocode}
                \bool_if:NT \c_@@_hyperref_loaded_bool
                   { 
                     \cs_set:Npn \This@name { equation }
                     \hyper@refstepcounter { equation }
                   }
%    \end{macrocode}
% Then, an action done by \pkg{cleveref} in its redefinition of
% |\refstepcounter|. The package \pkg{cleveref} creates in the |aux| file a
% command |\cref@currentlabel| similar to |\@currentlabel| but with more
% informations.
%    \begin{macrocode}        
                \bool_if:NT \c_@@_cleveref_loaded_bool
                   {
                     \cref@constructprefix { equation } { \cref@result }
                     \protected@edef \cref@currentlabel
                        { 
                          [ 
                            \cs_if_exist:NTF \cref@equation@alias 
                              \cref@equation@alias 
                              { equation } 
                          ] 
                          [ \arabic { equation } ] [ \cref@result ]
                          \p@equation \g_tmpa_tl
                        }
                   }
%    \end{macrocode}
% Then, an action done by \pkg{typedref} in its redefinition of
% |\refstepcounter|. The command |\sr@name| is a prefix added to the name of the
% label by the redefinition of |\label| done by \pkg{typedref}.
%    \begin{macrocode}
                \bool_if:NT \c_@@_typedref_loaded_bool
                   { \cs_set:Npn \sr@name { equation } }
%    \end{macrocode}
% Now, we can issue the command |\label| (some packages may have redefined
% |\label|, for example \pkg{typedref}) for each item in the sequence of the
% labels (it's possible to put several labels to the same line and that's why
% the labels are in the sequence |\l_@@_labels_seq|).
%    \begin{macrocode}
                \seq_map_function:NN \l_@@_labels_seq \@@_old_label
              }
%    \end{macrocode}
% We save the booleans |\l_@@_tag_star_bool| and |\l_@@_qedhere_bool| because
% they will be used in the \emph{next} cell (after the |&|). We recall that the
% cells of a |\halign| are TeX groups.
%    \begin{macrocode}
            \@@_save:N \l_@@_tag_star_bool
            \@@_save:N \l_@@_qedhere_bool
            \bool_if:NT \l_@@_tag_next_line_bool 
              { 
                \openup -\jot 
                \bool_set_false:N \l_@@_tag_next_line_bool 
                \notag \\ & 
              }
            & 
            \@@_restore:N \l_@@_tag_star_bool
            \@@_restore:N \l_@@_qedhere_bool
            \bool_if:NT \l_@@_qedhere_bool 
               { \hbox_overlap_left:n \@@_qedhere_i: }
            \cs_set_eq:NN \theequation \g_tmpa_tl
            \bool_if:NT \l_@@_tag_star_bool 
               { \cs_set_eq:NN \tagform@ \prg_do_nothing: }
%    \end{macrocode}
% We use |\@eqnnum| (we recall that there are two definitions of |\@eqnnum|, a
% standard definition and another, loaded if the class option |leqno| is used).
% However, of course, the position of the |v|-node is not the same wether the
% option |leqno| is used or not. That's here that we use the flag
% |\c_@@_leqno_bool|.
%    \begin{macrocode}
            \hbox_overlap_left:n 
              { 
                \bool_if:NF \c_@@_leqno_bool
                  { 
                    \tikz [ @@_standard ] 
                      \coordinate ( \int_use:N \g_@@_line_int - v ) ; 
                  }
                \quad
                \@eqnnum 
              }
            \bool_if:NT \c_@@_leqno_bool
              { 
                \tikz [ @@_standard ] 
                  \coordinate ( \int_use:N \g_@@_line_int - v ) ; 
              } 
          }
          { 
            \@@_save:N \l_@@_qedhere_bool 
            & 
            \@@_restore:N \l_@@_qedhere_bool
            \bool_if:NT \l_@@_qedhere_bool 
               { \hbox_overlap_left:n \@@_qedhere_i: }
            \tikz [ @@_standard ] 
               \coordinate ( \int_use:N \g_@@_line_int - v ) ; 
          }
        }
    \cr \noalign { \skip_vertical:n { #1 + \l_@@_interline_skip } \scan_stop: } 
  }
%    \end{macrocode}
% According to the documentation of \pkg{expl3}, the previous addition in 
% ``|#1 + \l_@@_interline_skip|'' is really an addition of skips (=glues).
%
%
% 
% \bigskip
% \subsection{The commands tag, notag, label, tagnextline and qedhere for
% DispWithArrows} 
%
% Some commands are allowed only in the second column of the environment
% |{DispWithArrows}|. We write a command |\@@_if_in_second_col_of_disp:Nn| to
% execute this command only if we are in the second column. If we are in the
% first column, an error is raised. The first argument of
% |\@@_if_in_second_col_of_disp:Nn| is the name of the command used in the error
% message and the second is the code to execute.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_if_in_second_col_of_disp:Nn
  { 
    \bool_if:NTF \l_@@_in_WithArrows_bool
      { \@@_error:nn { Not~allowed~in~WithArrows } { #1 } }
      { 
        \bool_if:NTF \l_@@_in_first_column_bool
          { \@@_error:nn { Not~allowed~in~DispWithArrows } { #1 } }
          { #2 }
      }
  }
%    \end{macrocode}
% 
% \bigskip
% The command |\@@_notag:| will be linked to |\notag| and |\nonumber| in the
% environments |{WithArrows}| and |{DispWithArrows}|.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_notag: 
  { \@@_if_in_second_col_of_disp:Nn \notag { \clist_clear:N \l_@@_tags_clist } }
%    \end{macrocode}
% 
%
% \bigskip
% The command |\@@_tag| will be linked to |\tag| in the environments
% |{WithArrows}| and |{DispWithArrows}|. We use |\NewDocumentCommand| because
% this command has a starred version.
%    \begin{macrocode}
\NewDocumentCommand \@@_tag { s m } 
  { 
    \@@_if_in_second_col_of_disp:Nn \tag
      { 
        \tl_if_empty:NF \l_@@_tag_tl
           { \@@_error:nn  { Multiple~tags } { #2 } }
        \clist_set:Nn \l_@@_tags_clist { all }
        \bool_if:nT \c_@@_mathtools_loaded_bool
          {
            \MH_if_boolean:nT { show_only_refs }
              {
                \MH_if_boolean:nF { show_manual_tags }
                  { \clist_clear:N \l_@@_tags_clist }
              }
          }
        \tl_set:Nn \l_@@_tag_tl { #2 }
        \bool_set:Nn \l_@@_tag_star_bool { #1 }
%    \end{macrocode}
% The starred version |\tag*| can't be used if \pkg{amsmath} has not been loaded
% because this version does the job by deactivating the command |\tagform@|
% inserted by \pkg{amsmath} in the (two versions of the) command
% |\@eqnnum|.\footnote{There are two versions of |@eqnnum|, a standard version
% and a version for the option |leqno|.}
%    \begin{macrocode}
        \bool_if:nT { #1 && ! \bool_if_p:N \c_@@_amsmath_loaded_bool }
          { \@@_error:n { tag*~without~amsmath } } 
      }
  }
%    \end{macrocode}
%
% \bigskip
% The command |\@@_label:n| will be linked to |\label| in the environments
% |{WithArrows}| and |{DispWithArrows}|. In these environments, it's possible to
% put several labels for the same line (it's not possible in the environments of
% \pkg{amsmath}). That's why we store the differents labels of a same line in a
% sequence |\l_@@_labels_seq|.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_label:n 
  {  
    \@@_if_in_second_col_of_disp:Nn \label
      { 
        \seq_if_empty:NF \l_@@_labels_seq 
          { 
            \bool_if:NTF \c_@@_cleveref_loaded_bool
              { \@@_error:n { Multiple~labels~with~cleveref } }
              { \@@_error:n { Multiple~labels } } 
          }
        \seq_put_right:Nn \l_@@_labels_seq { #1 }
        \bool_if:nT \c_@@_mathtools_loaded_bool
           {
             \MH_if_boolean:nT { show_only_refs } 
               { 
                 \cs_if_exist:cTF { MT_r_#1 }
                   { \clist_set:Nn \l_@@_tags_clist { all } }
                   { \clist_clear:N \l_@@_tags_clist } 
               }
           }
        \bool_if:nT \c_@@_autonum_loaded_bool
          { 
            \cs_if_exist:cTF { autonum@#1Referenced }
              { \clist_set:Nn \l_@@_tags_clist { all } }
              { \clist_clear:N \l_@@_tags_clist } 
          } 
      } 
  }
%    \end{macrocode}
%
% \bigskip
% The command |\@@_tagnextline:| will be linked to |\tagnextline| in the
% environments |{WithArrows}| and |{DispWithArrows}|.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_tagnextline:
  { 
    \@@_if_in_second_col_of_disp:Nn \tagnextline
      { \bool_set_true:N \l_@@_tag_next_line_bool }
  }
%    \end{macrocode}
%
%
% \bigskip
% The environments |{DispWithArrows}| and |{DispWithArrows*}| are compliant with
% the command |\qedhere| of \pkg{amsthm}. However, this compatibility requires a
% special version of |\qedhere|.
% 
% This special version is called |\@@_qedhere:| and will be linked with
% |\qedhere| in the second column of the environment |{DispWithArrows}| (only if
% the package \pkg{amsthm} has been loaded). |\@@_qedhere:| raises the boolean
% |\l_@@_qedhere_bool|.
%    \begin{macrocode}
\bool_new:N \l_@@_qedhere_bool
\cs_new_protected:Nn \@@_qedhere: { \bool_set_true:N \l_@@_qedhere_bool }
%    \end{macrocode}
%
% In the third column of the |\halign| of |{DispWithArrows}|, a command
% |\@@_qedhere_i:| will be issued if the flag |\l_@@_qedhere_bool| has been
% raised. The code of this command is an adaptation of the code of |\qedhere| in
% \pkg{amsthm}.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_qedhere_i: 
  {
    \group_begin:
      \cs_set_eq:NN \qed \qedsymbol
%    \end{macrocode}
% The line |\cs_set_eq:NN \qed@elt \setQED@elt| is a preparation for an action
% on the \textsc{qed} stack. Despite its form, the instruction |\QED@stack|
% executes an operation on the stack. This operation prints the \textsc{qed}
% symbol and nullify the top of the stack.
%    \begin{macrocode}
      \cs_set_eq:NN \qed@elt \setQED@elt 
      \QED@stack \relax \relax 
    \group_end: 
  }
%    \end{macrocode}
% 
% 
% \bigskip
% \subsection{The environment \{DispWithArrows\}}
%
%
% For the environment |{DispWithArrows}|, the construction is a construction of
% the type:
%
% |\[\vcenter{\halign to \displaywith {...}}\]|
% 
% The purpose of the |\vcenter| is to have an environment unbreakable.
% 
% \bigskip
%    \begin{macrocode}
\NewDocumentEnvironment { DispWithArrows } { ! O { } }
  { 
%    \end{macrocode}
% If \pkg{mathtools} has been loaded with the option |showonlyrefs|, we disable
% the code of \pkg{mathtools} for the option |showonlyrefs| with the command
% |\MT_showonlyrefs_false:| (it will be reactivated at the end of the
% environment).
%    \begin{macrocode}
    \bool_if:nT \c_@@_mathtools_loaded_bool 
      { 
        \MH_if_boolean:nT { show_only_refs } 
          {
            \MT_showonlyrefs_false:
%    \end{macrocode}
% However, we have to re-raise the flag |{show_only_refs}| of \pkg{mhsetup}
% because it has been switched off by |\MT_showonlyrefs_false:| and we will use
% it in the code of the new version of |\label|.
%    \begin{macrocode}
            \MH_set_boolean_T:n { show_only_refs } 
          }
      }
%    \end{macrocode}
% The command |\intertext@| is a command of \pkg{amsmath} which loads the
% definition of |\intertext|.
%    \begin{macrocode}
    \bool_if:NT \c_@@_amsmath_loaded_bool \intertext@
    \bool_set_true:N \l_@@_in_DispWithArrows_bool
    \@@_pre_environment:n { #1 }
    \if_mode_math:
      \@@_error:n { DispWithArrows~in~math~mode }
    \fi:
%    \end{macrocode}
% We don't use |\[| of LaTeX because some extensions, like \pkg{autonum}, do a
% redefinition of |\[|. However, we put the following lines which are in the
% definition of |\[| even though they are in case of misuse.
%    \begin{macrocode}
    \if_mode_vertical:
      \nointerlineskip
      \makebox [ .6 \linewidth ] { }
    \fi:
    $$
%    \end{macrocode}
% We use a |\vcenter| in order to prevent page breaks in the environment.
%    \begin{macrocode}
    \vcenter \bgroup 
    \spread@equation 
    \bool_if:NTF \l_@@_fleqn_bool
      { \tabskip = \c_zero_skip }
      { \tabskip = 0 pt plus 1000 pt minus 1000 pt }
    \cs_set_eq:NN \@@_old_label \label
    \cs_set_eq:NN \notag \@@_notag:
    \cs_set_eq:NN \nonumber \@@_notag:
    \cs_set_eq:NN \tag \@@_tag
    \cs_set_eq:NN \label \@@_label:n
    \cs_set_eq:NN \tagnextline \@@_tagnextline:
    \halign to \displaywidth 
    \bgroup
    \int_gincr:N \g_@@_line_int
    \cs_set_eq:cN \l_@@_CommandName_str \@@_Arrow_first_column:
    \bool_set_true:N \l_@@_in_first_column_bool
    \strut
    \bool_if:NT \l_@@_fleqn_bool { \skip_horizontal:n \l_@@_mathindent_dim }
    \hfil
    $
    \bool_if:NT \l_@@_displaystyle_bool \displaystyle 
    { ## } 
    $
    \tabskip = \c_zero_skip
    &
    \clist_if_in:NVT \l_@@_tags_clist \g_@@_line_int
         { \clist_set:Nn \l_@@_tags_clist { all } }
%    \end{macrocode}
% The command |\qedhere| of \pkg{amsthm} is redefined here. 
%    \begin{macrocode}
    \bool_if:NT \c_@@_amsthm_loaded_bool 
      { \cs_set_eq:NN \qedhere \@@_qedhere: }
    $
    \bool_if:NT \l_@@_displaystyle_bool \displaystyle 
    { { } ## }
    $
    \tabskip = 0 pt plus 1000 pt minus 1000 pt
    \tikz [ remember~picture , overlay ]
      \node 
        [ 
          node~contents = { } ,
          @@_node_style ,
          name = wa - \l_@@_prefix_str - \int_use:N \g_@@_line_int - l ,
          alias = 
            { 
              \str_if_empty:NF \l_@@_name_str 
                { \l_@@_name_str - \int_use:N \g_@@_line_int - l } 
            } 
        ] 
        ;
    \hfil
    \tikz [ remember~picture , overlay ]
      \node 
        [
          node~contents = { } ,
          @@_node_style ,
          name = wa - \l_@@_prefix_str - \int_use:N \g_@@_line_int - r ,
          alias = 
            { 
              \str_if_empty:NF \l_@@_name_str
                { \l_@@_name_str - \int_use:N \g_@@_line_int - r } 
            } 
        ] 
        ;
    \bool_if:NT \l_@@_show_node_names_bool
       { 
         \hbox_overlap_right:n 
           { \small wa - \l_@@_prefix_str - \int_use:N \g_@@_line_int } 
       }
    & 
    ##
    \tabskip = \c_zero_skip
    && 
    \@@_error:n { Third~column~in~DispWithArrows } 
    \iffalse ## \fi
    \cr
  }
%    \end{macrocode}
% We begin the second part of the environment |{DispWithArrows}|.
%    \begin{macrocode}
  { 
    \clist_if_in:NnT \l_@@_tags_clist { last }
      { \clist_set:Nn \l_@@_tags_clist { all } }
    \\
%    \end{macrocode}
% The following |\egroup| is for the |\halign|.
%    \begin{macrocode}
    \egroup 
%    \end{macrocode}
% The following |\egroup| is for the |\vcenter| (aimed to prevent page breaks).
%    \begin{macrocode}
    \egroup 
%    \end{macrocode}
%
% If we are in an environment |{DispWithArrows}| or |{DispWithArrows*}|, we
% compute the dimension |\g_@@_right_x_dim|. As a first approximation,
% |\g_@@_right_x_dim| is the $x$-value of the right side of the current
% composition box. In fact, we must take into account the potential labels of
% the equations. That's why we compute |\g_@@_right_x_dim| with the |v|-nodes of
% each row specifically built in this goal. |\g_@@_right_x_dim| is the minimal
% value of the $x$-value of these nodes.
%    \begin{macrocode}
    \bool_if:NT \l_@@_in_DispWithArrows_bool
      { 
        \dim_gzero_new:N \g_@@_right_x_dim 
        \dim_gset_eq:NN \g_@@_right_x_dim \c_max_dim
        \begin { tikzpicture } [ @@_standard ]
          \int_step_variable:nNn \g_@@_line_int \l_tmpa_int
             { 
               \cs_if_free:cTF 
                 { pgf@sh@ns@wa - \l_@@_prefix_str - \l_tmpa_int - v }
                 { \@@_error:n { Inexistent~v-node } }
                 { 
                   \tikz@parse@node\pgfutil@firstofone ( \l_tmpa_int - v )
                   \dim_set:Nn \l_tmpa_dim \pgf@x
                   \dim_compare:nNnT \l_tmpa_dim < \g_@@_right_x_dim
                      { \dim_gset:Nn \g_@@_right_x_dim \l_tmpa_dim } 
                 } 
             }
        \end { tikzpicture } 
      }
%    \end{macrocode}
% 
% \bigskip
% The code in |\@@_post_environment:| is common to |{WithArrows}| and
% |{DispWithArrows}|.
%    \begin{macrocode}
    \@@_post_environment:
%    \end{macrocode}
% If \pkg{mathtools} has been loaded with the option |showonlyrefs|, we
% reactivate the code of \pkg{mathtools} for the option |showonlyrefs| with the
% command |\MT_showonlyrefs_true:| (it has been deactivated in the beginning of
% the environment).
%    \begin{macrocode}
    \bool_if:nT \c_@@_mathtools_loaded_bool
      { \MH_if_boolean:nT { show_only_refs } \MT_showonlyrefs_true: }
    $$
%    \end{macrocode}
%
% \bigskip 
% If the option |footnote| or the option |footnotehyper| is used, then we
% extract the footnotes with an environment |{savenotes}| (of the package
% \pkg{footnote} or the package \pkg{footnotehyper}).
%    \begin{macrocode}
    \bool_if:NT \g_@@_footnote_bool { \end {savenotes } }
    \ignorespacesafterend
  }
%    \end{macrocode}
%
% \bigskip
% With the environment |{DispWithArrows*}|, the equations are not numbered. We
% don't put |\begin{DispWithArrows}| and |\end{DispWithArrows}| because there is
% a |\@currenvir| in some error messages.
%    \begin{macrocode}
\NewDocumentEnvironment { DispWithArrows* } {}
   { 
     \WithArrowsOptions { notag }
     \DispWithArrows
   }
   { \endDispWithArrows }
%    \end{macrocode}
%
%
% \subsection{We draw the arrows}
%
% \bigskip
% The arrows are divided in groups. There is two reasons for this division.
% \begin{itemize}
% \item If the option |group| or the option |groups| is used, all the arrows are
% drawn on a same vertical at an abscissa of |\l_@@_x_dim|.
% \item For aesthetic reasons, the starting point of all the starting arrows of
% a group is raised upwards by the value |\l_@@_start_adjust_dim|. Idem for the
% ending arrows.
% \end{itemize}
% 
% \medskip
% If the option |group| is used (|\l_@@_pos_arrow_int| = 7), we scan the arrows
% twice: in the first step we only compute the value of |\l_@@_x_dim| for the
% whole group, and, in the second step (|\l_@@_pos_arrow_int| is set to 8), we
% divide the arrows in groups (for the vertical adjustement) and we actually
% draw the arrows.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_scan_arrows:
 { 
   \group_begin:
   \int_compare:nNnT \l_@@_pos_arrow_int = 7
      { 
        \@@_scan_arrows_i:
        \int_set:Nn \l_@@_pos_arrow_int 8 
      }
   \@@_scan_arrows_i:
   \group_end:
 }
%    \end{macrocode}
% 
% \bigskip
% If an environment |{WithArrows}| is composed with the option |group| or the
% option |groups|, it's still possible to put arrows with their option of
% position (|ll|, |rr|, |rl|, |lr| or |i|). Such arrows will be said to be
% ``independent''.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_scan_arrows_i:
  { 
%    \end{macrocode}
%
% \bigskip 
% |\l_@@_first_arrow_of_group_int| will be the first arrow of the current group.
%
% |\l_@@_first_line_of_group_int| will be the first line involved in the group
% of arrows (equal to the initial line of the first arrow of the group because
% the option |jump| is always positive).
%
% |\l_@@_first_arrows_of_group_seq| will the list the arrows of the group
% starting at the first line of the group (we may have several arrows starting
% from the same line). We have to known all these arrows because of the
% adjustement by |\l_@@_start_adjust_dim|.
%
% |\l_@@_last_line_of_group_int| will be the last line involved in the group
% (impossible to guess in advance).
%
% |\l_@@_last_arrows_of_group_seq| will the list of all the arrows of the group
% ending at the last line of the group (impossible to guess in advance).
%    \begin{macrocode}
    \int_zero_new:N \l_@@_first_arrow_of_group_int 
    \int_zero_new:N \l_@@_first_line_of_group_int
    \int_zero_new:N \l_@@_last_line_of_group_int
    \seq_clear_new:N \l_@@_first_arrows_of_group_seq
    \seq_clear_new:N \l_@@_last_arrows_of_group_seq
    \bool_set_true:N \l_@@_new_group_bool
%    \end{macrocode}
%
% \bigskip
% We begin a loop over all the arrows of the environment. Inside this loop, if a
% group is finished, we will draw the arrows of that group.
%    \begin{macrocode}
    \int_set:Nn \l_@@_arrow_int \c_one_int
    \int_until_do:nNnn \l_@@_arrow_int > \g_@@_arrow_int
      { 
%    \end{macrocode}
%
% \bigskip 
% We extract from the property list of the current arrow the fields ``initial'',
% ``final'' and ``position'' and we store these values in |\l_@@_initial_int|,
% |\l_@@_final_int| and |\l_@@_pos_of_arrow_int|. However, we have to do a
% conversion because the components of a property list are token lists.
%    \begin{macrocode}
        \prop_get:cnN 
          { g_@@_arrow _ \l_@@_prefix_str _ \int_use:N \l_@@_arrow_int _ prop }
          { initial } \l_tmpa_tl
        \int_set:Nn \l_@@_initial_int \l_tmpa_tl
        \prop_get:cnN 
          { g_@@_arrow _ \l_@@_prefix_str _ \int_use:N \l_@@_arrow_int _ prop }
          { final } \l_tmpa_tl
        \int_set:Nn \l_@@_final_int \l_tmpa_tl
        \prop_get:cnN 
          { g_@@_arrow _ \l_@@_prefix_str _ \int_use:N \l_@@_arrow_int _ prop }
          { status } \l_@@_status_arrow_str
        \prop_get:cnN 
          { g_@@_arrow _ \l_@@_prefix_str _ \int_use:N \l_@@_arrow_int _ prop }
          { input-line } \l_@@_input_line_str
%    \end{macrocode}
%
% \bigskip
% If the arrow arrives after the last line of the environment we raise an error
% (we recall that, after the construction of the |\halign|, |\g_@@_line_int| is
% the total number of lines of the environment). The arrow will be completely
% ignored, even for the computation of |\l_@@_x_dim|.
%    \begin{macrocode}
        \int_compare:nNnTF \l_@@_final_int > \g_@@_line_int
           { \@@_error:n { Too~few~lines~for~an~arrow } }
%    \end{macrocode}
%
% \bigskip
% We test if the previous arrow was in fact the last arrow of a group. In this
% case, we have to draw all the arrows of that group, except if you are with the
% option |group| and in the first step of treatment (|\l_@@_pos_arrow_int| = 7).
%    \begin{macrocode}
           { 
             \bool_if:nT 
               { 
                 \int_compare_p:nNn \l_@@_arrow_int > 1
                 && 
                ( \int_compare_p:n 
                    { \l_@@_initial_int > \l_@@_last_line_of_group_int }
                 &&
                  \int_compare_p:n { \l_@@_pos_arrow_int != 7 }
                 ||
                  \str_if_eq_p:Vn \l_@@_status_arrow_str { new-group }
                ) 
               }
               { 
                 \int_compare:nNnF \l_@@_first_arrow_of_group_int = 0
                   { 
                     \@@_draw_arrows:nn 
                       \l_@@_first_arrow_of_group_int 
                       { \l_@@_arrow_int - 1 } 
                   }
                 \bool_set_true:N \l_@@_new_group_bool
               }
%    \end{macrocode}
%
% \bigskip
% The flag |\l_@@_new_group_bool| indicates if we have to begin a new group of
% arrows. In fact, we have to begin a new group in two circonstancies: if we are
% at the first arrow of the environment (that's why the flag is raised before
% the beginning of the loop) and if we have just finished a group (that's why
% the flag is raised in the previous conditionnal). At the beginning of a group,
% we have to initialize the following variables: |\l_@@_first_arrow_int|,
% |\l_@@_first_line_of_group_int|, |\l_@@_last_line_of_group|,
% |\l_@@_first_arrows_of_group_seq|, |\l_@@_last_arrows_of_group_seq|.
%
%    \begin{macrocode}
             \bool_if:nTF \l_@@_new_group_bool
                { 
                  \bool_set_false:N \l_@@_new_group_bool
                  \int_set_eq:NN \l_@@_first_arrow_of_group_int \l_@@_arrow_int
                  \int_set_eq:NN \l_@@_first_line_of_group_int \l_@@_initial_int
                  \int_set_eq:NN \l_@@_last_line_of_group_int \l_@@_final_int
                  \seq_clear:N \l_@@_first_arrows_of_group_seq 
                  \seq_put_left:NV \l_@@_first_arrows_of_group_seq 
                    \l_@@_arrow_int
                  \seq_clear:N \l_@@_last_arrows_of_group_seq 
                  \seq_put_left:NV \l_@@_last_arrows_of_group_seq 
                    \l_@@_arrow_int
%    \end{macrocode}
%
% If we are in option |group| and in the second step of treatment
% (|\l_@@_pos_arrow_int| = 8), we don't initialize |\l_@@_x_dim| because we want
% to use the same value of |\l_@@_x_dim| (computed during the first step) for
% all the groups.
%    \begin{macrocode}
                  \int_compare:nT { \l_@@_pos_arrow_int != 8 }
                    { \dim_set:Nn \l_@@_x_dim { - \c_max_dim } }
                }
%    \end{macrocode}
%
% \bigskip
% If we are not at the beginning of a new group, we actualize
% |\l_@@_last_line_of_group_int|. If the arrow is independent, we don't take
% into account this arrow for the detection of the end of the group.
%    \begin{macrocode}
                { 
                  \bool_if:nF 
                     { \str_if_eq_p:Vn \l_@@_status_arrow_str { independent } }
                     { 
                       \int_compare:nT 
                         { \l_@@_initial_int = \l_@@_first_line_of_group_int }
                         { 
                           \seq_put_left:NV \l_@@_first_arrows_of_group_seq 
                             \l_@@_arrow_int 
                         }
                       \int_compare:nTF 
                         { \l_@@_final_int > \l_@@_last_line_of_group_int }
                         { 
                           \int_set_eq:NN \l_@@_last_line_of_group_int 
                             \l_@@_final_int
                           \seq_clear:N \l_@@_last_arrows_of_group_seq
                           \seq_put_left:NV \l_@@_last_arrows_of_group_seq 
                             \l_@@_arrow_int
                         }
                         { 
                           \int_compare:nNnT 
                             \l_@@_final_int = \l_@@_last_line_of_group_int 
                             { 
                               \seq_put_left:NV \l_@@_last_arrows_of_group_seq
                                 \l_@@_arrow_int 
                             }
                         }
                     }
                }
%    \end{macrocode}
%
% \bigskip 
% If the arrow is not independent, we update the current $x$-value (in 
% |\l_@@_x_dim|) with the dedicated command |\@@_update_x:nn|. If we are
% in option |group| and in the second step of treatment (|\l_@@_pos_arrow_int| =
% 8), we don't initialize |\l_@@_x_dim| because we want to use the same value of
% |\l_@@_x_dim| (computed during the first step) for all the groups.
%    \begin{macrocode}
             \bool_if:nF 
                { \str_if_eq_p:Vn \l_@@_status_arrow_str { independent } }
                { 
                  \int_compare:nT { \l_@@_pos_arrow_int != 8 }
                    { \@@_update_x:nn \l_@@_initial_int \l_@@_final_int }
                } 
            }
%    \end{macrocode}
%
% \bigskip
% Incrementation of the index of the loop (and end of the loop).
%    \begin{macrocode}
        \int_incr:N \l_@@_arrow_int
      }
%    \end{macrocode}
%
% \bigskip
% After the last arrow of the environment, we have to draw the last group of
% arrows. If we are in option |group| and in the first step of treatment
% (|\l_@@_pos_arrow_int| = 7), we don't draw because, in the first step, we
% don't draw anything.
%    \begin{macrocode}
     \int_compare:nT { \l_@@_pos_arrow_int != 7 }
        { \@@_draw_arrows:nn \l_@@_first_arrow_of_group_int \g_@@_arrow_int }
  }
%    \end{macrocode}
%
% \bigskip
% The following code is necessary because we will have to expand an argument
% exactly 3 times.
%    \begin{macrocode}
\cs_generate_variant:Nn \keys_set:nn { n o }
\cs_new_protected:Nn \@@_keys_set: 
  { \keys_set_known:no { WithArrows / Arrow / SecondPass } }
%    \end{macrocode}
%
% \bigskip
% The macro |\@@_draw_arrows:nn| draws all the arrows whose numbers are between
% |#1| and |#2|. |#1| and |#2| must be expressions that expands to an integer
% (they are expanded in the beginning of the macro).
%    \begin{macrocode}
\cs_new_protected:Nn \@@_draw_arrows:nn
  {
    \group_begin:
    \int_zero_new:N \l_@@_first_arrow_int
    \int_set:Nn \l_@@_first_arrow_int { #1 }
    \int_zero_new:N \l_@@_last_arrow_int
    \int_set:Nn \l_@@_last_arrow_int { #2 }
%    \end{macrocode}
%
% \bigskip
% We begin a loop over the arrows we have to draw. The variable
% |\l_@@_arrow_int| (local in the environment |{WithArrows}|) will be used as
% index for the loop.
%    \begin{macrocode}
    \int_set:Nn \l_@@_arrow_int \l_@@_first_arrow_int
    \int_until_do:nNnn \l_@@_arrow_int > \l_@@_last_arrow_int
      {
%    \end{macrocode}
%
% \bigskip 
% We extract from the property list of the current arrow the fields ``initial''
% and ``final'' and we store these values in |\l_@@_initial_int| and
% |\l_@@_final_int|. However, we have to do a conversion because the components
% of a property list are token lists.
%    \begin{macrocode}
        \prop_get:cnN 
          { g_@@_arrow _ \l_@@_prefix_str _ \int_use:N \l_@@_arrow_int _ prop }
          { initial } \l_tmpa_tl
        \int_set:Nn \l_@@_initial_int \l_tmpa_tl
        \prop_get:cnN 
          { g_@@_arrow _ \l_@@_prefix_str _ \int_use:N \l_@@_arrow_int _ prop }
          { final } \l_tmpa_tl
        \int_set:Nn \l_@@_final_int \l_tmpa_tl
%    \end{macrocode}
%
% \bigskip
% If the arrow ends after the last line of the environment, we don't draw the
% arrow (an error has already been raised in |\@@_scan_arrows:|). We recall
% that, after the construction of the |\halign|, |\g_@@_line_int| is the total
% number of lines of the environment).
%    \begin{macrocode}
        \int_compare:nT { \l_@@_final_int <= \g_@@_line_int } \@@_draw_arrows_i:
        \int_incr:N \l_@@_arrow_int
      } 
    \group_end:
  }
%    \end{macrocode}
%
% \bigskip
% The macro |\@@_draw_arrows_i:| is only for the lisibility of the code. The
% first |\group_begin:| is for the options of the arrows (but we remind that the
% options |ll|, |rr|, |rl|, |lr|, |i| and |jump| have already been extracted and
% are not present in the field |options| of the property list of the arrow).
%    \begin{macrocode}
\cs_new_protected:Nn \@@_draw_arrows_i:
  { 
    \group_begin:
%    \end{macrocode}
%
% \bigskip
% We process the options of the current arrow. The second argument of
% |\keys_set:nn| must be expanded exactly three times. An x-expansion is not
% possible because there can be tokens like |\bfseries| in the option |font| of
% the option |tikz|. This expansion is a bit tricky.
%    \begin{macrocode}
    \prop_get:cnN 
      { g_@@_arrow _\l_@@_prefix_str _ \int_use:N \l_@@_arrow_int _ prop } 
      { options } \l_tmpa_tl
    \str_clear_new:N \l_@@_previous_key_str
    \exp_args:NNo \exp_args:No 
    \@@_keys_set: { \l_tmpa_tl , tikz = { xshift = \l_@@_xoffset_dim } }
%    \end{macrocode}
%
% We create two booleans to indicate the position of the initial node and final
% node of the arrow in cases of options |rr|, |rl|, |lr| or |ll|:
%    \begin{macrocode}
    \bool_set_false:N \l_@@_initial_r_bool
    \bool_set_false:N \l_@@_final_r_bool
    \int_case:nn \l_@@_pos_arrow_int 
      {
        0 { \bool_set_true:N \l_@@_final_r_bool }
        2 { \bool_set_true:N \l_@@_initial_r_bool }
        3 { 
            \bool_set_true:N \l_@@_initial_r_bool
            \bool_set_true:N \l_@@_final_r_bool 
          }
      }
%    \end{macrocode}
%
% \bigskip
% \begin{center}
% \begin{tabular}{l}
% \begin{tabular}{@{}l*8c@{}}
% \toprule
% option                 & |lr| & |ll| & |rl| & |rr| & |v| & |i| & |groups| & |group| \\
% \midrule
% |\l_@@_pos_arrow_int| & $0$  & $1$  & $2$  & $3$  & $4$ & $5$  & $6$  & $7$  \\
% \bottomrule
% \end{tabular} \\
% \footnotesize The option |v| can be used only in |\Arrow| in |CodeAfter| (see
% below). 
% \end{tabular}
% \end{center}
% 
% \bigskip
% In case of option |i| at a local or global level (|\l_@@_pos_arrow_int| = 5),
% we have to compute the $x$-value of the arrow (which is vertical). The
% computed $x$-value is stored in |\l_@@_x_dim| (the same variable used when the
% option |group| or the option |groups| is used).
%    \begin{macrocode}
    \int_compare:nNnT \l_@@_pos_arrow_int = 5
       { 
         \dim_set:Nn \l_@@_x_dim { - \c_max_dim }
         \@@_update_x:nn \l_@@_initial_int \l_@@_final_int 
       }
%    \end{macrocode}
%
% \bigskip
% |\l_@@_initial_tl| contains the name of the Tikz node from which the arrow
% starts (in normal cases... because with the option |i|, |group| and |groups|,
% the point will perhaps have another
% $x$-value --- but always the same $y$-value). Idem for |\l_@@_final_tl|.
%    \begin{macrocode}
    \tl_set:Nx \l_@@_initial_tl 
       { \int_use:N \l_@@_initial_int - \bool_if:NTF \l_@@_initial_r_bool rl .south } 
    \tl_set:Nx \l_@@_final_tl 
       { \int_use:N \l_@@_final_int - \bool_if:NTF \l_@@_final_r_bool rl .north }
%    \end{macrocode}
% We use ``|.south|'' and ``|.north|'' because we want a small gap between two
% consecutive arrows (and the Tikz nodes created have the shape of small
% vertical segments: use option |show-nodes| to visualize the nodes).
%
% \bigskip
% The label of the arrow will be stored in |\l_tmpa_tl|.
%    \begin{macrocode}
    \prop_get:cnN 
      { g_@@_arrow _ \l_@@_prefix_str _ \int_use:N \l_@@_arrow_int _ prop } 
      { label } 
      \l_tmpa_tl 
%    \end{macrocode}
%
% \bigskip
% Now, we have to know if the arrow starts at the first line of the group and/or
% ends at the last line of the group. That's the reason why we have stored in
% |\l_@@_first_arrows_of_group_seq| the list of all the arrows starting at the
% first line of the group and in |\l_@@_last_arrows_of_group_seq| the list of
% all the arrows ending at the last line of the group. We compute these values
% in the booleans |\l_tmpa_bool| and |\l_tmpb_bool|. These computations can't be
% done in the following |{tikzpicture}| because the command |\seq_if_in:NTF|
% which is \emph{not} expandable.
%    \begin{macrocode}
    \seq_if_in:NxTF \l_@@_first_arrows_of_group_seq 
       { \int_use:N \l_@@_arrow_int }
       { \bool_set_true:N \l_tmpa_bool }
       { \bool_set_false:N \l_tmpa_bool }
    \seq_if_in:NxTF \l_@@_last_arrows_of_group_seq 
       { \int_use:N \l_@@_arrow_int } 
       { \bool_set_true:N \l_tmpb_bool }
       { \bool_set_false:N \l_tmpb_bool }
    \int_compare:nNnT \l_@@_pos_arrow_int = 5
       { 
         \bool_set_true:N \l_tmpa_bool
         \bool_set_true:N \l_tmpb_bool 
       }
%    \end{macrocode}
%
% \bigskip 
% We compute and store in |\g_tmpa_tl| and |\g_tmpb_tl| the exact coordinates of
% the extremities of the arrow.
% \begin{itemize}
% \item Concerning the
% $x$-values, the abscissa computed in |\l_@@_x_dim| will be used if the option
% of position is |i|, |group| or |groups|.
% \item Concerning the
% $y$-values, an adjustement is done for each arrow starting at the first line
% of the group and each arrow ending at the last line of the group (with the
% values of |\l_@@_start_adjust_dim| and |\l_@@_end_adjust_dim|).
% \end{itemize}
% 
%    \begin{macrocode}
    \begin { tikzpicture } [ @@_standard ]
       \tikz@scan@one@point \pgfutil@firstofone ( \l_@@_initial_tl )
       \tl_gset:Nx \g_tmpa_tl 
          {
            \int_compare:nNnTF \l_@@_pos_arrow_int < 5
              { \dim_use:N \pgf@x }
              { \dim_use:N \l_@@_x_dim } , 
            \bool_if:NTF \l_tmpa_bool
              { \dim_eval:n { \pgf@y + \l_@@_start_adjust_dim } }
              { \dim_use:N \pgf@y } 
          }
       \tikz@scan@one@point \pgfutil@firstofone ( \l_@@_final_tl )
       \tl_gset:Nx \g_tmpb_tl 
          {
            \int_compare:nNnTF \l_@@_pos_arrow_int < 5 
              { \dim_use:N \pgf@x }
              { \dim_use:N \l_@@_x_dim } , 
            \bool_if:NTF \l_tmpb_bool
              { \dim_eval:n { \pgf@y - \l_@@_end_adjust_dim } }
              { \dim_use:N \pgf@y } 
          } 
    \end { tikzpicture } 
%    \end{macrocode}
%
% \bigskip
% Eventually, we can draw the arrow with the code in |\l_@@_tikz_code_tl|. We
% recall that the value by default for this token list is :\enskip
% ``\verb|\draw (#1) to node {#3} (#2) ;|''. This value can be modified with the
% option |TikzCode|. We use the variant |\@@_draw_arrow:nno| of the macro
% |\@@_draw_arrow:nnn| because of the characters \emph{underscore} in the name
% |\l_tmpa_tl|: if the user uses the Tikz library |babel|, the third argument of
% the command |\@@_draw_arrow:nno| will be rescanned because this third argument
% will be in the argument of a command |node| of an instruction |\draw| of
% Tikz... and we will have an error because of the characters
% \emph{underscore}.\footnote{There were other solutions: use another name
% without \emph{underscore} (like \Verb|\ltmpatl|) or use the package
% \pkg{underscore} (with this package, the characters \emph{underscore} will be
% rescanned without errors, even in text mode).}
%    \begin{macrocode}
    \@@_draw_arrow:nno \g_tmpa_tl \g_tmpb_tl \l_tmpa_tl
%    \end{macrocode}
%
% \smallskip
% We close the TeX group opened for the options given to |\Arrow[...]| (local
% level of the options).
%    \begin{macrocode}
    \group_end: 
  }
%    \end{macrocode}
%
%
% \bigskip
% The function |@@_tmpa:nnn| will draw the arrow. It's merely an environment
% |{tikzpicture}|. However, the Tikz instruction in this environment must be
% inserted from |\l_@@_tikz_code_tl| with the markers |#1|, |#2| and |#3|.
% That's why we create a function |\@@_def_function_tmpa:n| which will create
% the function |\@@_tmpa:nnn|.
%    \begin{macrocode}
\cs_new_protected:Nn \@@_def_function_tmpa:n 
  { 
    \cs_set:Npn \@@_tmpa:nnn ##1 ##2 ##3
      { 
        \begin{tikzpicture} 
          [ 
            @@_standard , 
            every~path / .style = WithArrows / arrow 
          ] 
          #1 
        \end{tikzpicture}
      }
  }
%    \end{macrocode}
%
% \medskip
% When we draw the arrow (with |\@@_draw_arrow:nnn|), we first create the
% function |\@@_tmpa:nnn| and, then, we use the function |\@@_tmpa:nnn| :
%    \begin{macrocode}
\cs_new_protected:Nn \@@_draw_arrow:nnn
  {
%    \end{macrocode}
%
% \medskip
% If the option |wrap-lines| is used, we have to use a special version of
% |\l_@@_tikz_code_tl| (which corresponds to the option |TikzCode|).
%    \begin{macrocode}
    \bool_if:nT { \l_@@_wrap_lines_bool && \l_@@_in_DispWithArrows_bool }
       { \tl_set_eq:NN \l_@@_tikz_code_tl \c_@@_tikz_code_wrap_lines_tl }
%    \end{macrocode}
% 
% \medskip
% Now, the main lines of this function |\@@_draw_arrow:nnn|.
%    \begin{macrocode}
    \exp_args:NV \@@_def_function_tmpa:n \l_@@_tikz_code_tl
    \@@_tmpa:nnn { #1 } { #2 } { #3 } 
  }
\cs_generate_variant:Nn \@@_draw_arrow:nnn { n n o }
%    \end{macrocode}
% 
% \bigskip
% If the option |wrap-lines| is used, we have to use a special version of
% |\l_@@_tikz_code_tl| (which corresponds to the option |TikzCode|).
%    \begin{macrocode}
\tl_const:Nn \c_@@_tikz_code_wrap_lines_tl
  { 
%    \end{macrocode}
% First, we draw the arrow without the label.
%    \begin{macrocode}
    \draw ( #1 ) to node ( @@_label ) { } ( #2 ) ;
%    \end{macrocode}
% We retrieve in |\pgf@x| the abscissa of the left-side of the label we will
% put.
%    \begin{macrocode}
    \tikz@parse@node \pgfutil@firstofone ( @@_label.west )
%    \end{macrocode}
% We compute in |\l_tmpa_dim| the maximal width possible for the label. 
% |0.3333 em| is the default value of |inner sep| in the nodes of Tikz. Maybe we
% should put the exact Tikz parameter. Here is the use of |\g_@@_right_x_dim|
% which has been computed previously with the |v|-nodes.
%    \begin{macrocode}
    \dim_set:Nn \l_tmpa_dim { \g_@@_right_x_dim - \pgf@x - 0.3333 em } 
%    \end{macrocode}
% We retrieve in |\g_tmpa_tl| the current value of the Tikz parameter 
% ``|text width|''.\footnote{In fact, it's not the current value of 
% ``|text width|'': it's the value of ``|text width|'' set in the option |tikz|
% provided by \pkg{witharrows}. These options are given to Tikz in a 
% ``|every path|''. That's why we have to retrieve it in a path.}
%    \begin{macrocode}
    \path \pgfextra { \tl_gset:Nx \g_tmpa_tl \tikz@text@width } ;
%    \end{macrocode}
% Maybe the current value of the parameter ``|text width|'' is shorter than
% |\l_tmpa_dim|. In this case, we must use ``|text width|'' (we update
% |\l_tmpa_dim|).
%    \begin{macrocode}
    \tl_if_empty:NF \g_tmpa_tl
       {
         \dim_set:Nn \l_tmpb_dim \g_tmpa_tl
         \dim_compare:nNnT \l_tmpb_dim < \l_tmpa_dim
           { \dim_set_eq:NN \l_tmpa_dim \l_tmpb_dim }
       }
%    \end{macrocode}
% Now, we can put the label with the right value for ``|text width|''.
%    \begin{macrocode}
    \dim_compare:nNnT \l_tmpa_dim > \c_zero_dim
      { 
        \path ( @@_label.west ) 
           node [ anchor = west , text~width = \dim_use:N \l_tmpa_dim ] 
                { #3 } ; 
      } 
  }
%    \end{macrocode}
% 
% \bigskip
% The command |\@@_update_x:nn| will analyze the lines between |#1| and
% |#2| in order to modify |\l_@@_x_dim| in consequence. More precisely,
% |\l_@@_x_dim| is increased if a line longer than the current value of
% |\l_@@_x_dim| is found. |\@@_update_x:nn| is used in |\@@_scan_arrows:|
% (for options |group| and |groups|) and in |\@@_draw_arrows:nn| (for option
% |i|).
%    \begin{macrocode}
\cs_new_protected:Nn \@@_update_x:nn
  { 
    \int_step_inline:nnn { #1 } { #2 } 
       { 
         \begin { tikzpicture } [ @@_standard ]
           \tikz@scan@one@point \pgfutil@firstofone ( ##1 - l )
           \dim_gset:Nn \g_tmpa_dim { \dim_max:nn \l_@@_x_dim \pgf@x }
         \end { tikzpicture }
         \dim_set_eq:NN \l_@@_x_dim \g_tmpa_dim 
       } 
  } 
%    \end{macrocode}
%
%
% \bigskip
% The command |\WithArrowsLastEnv| is not used by the package \pkg{witharrows}.
% It's only a facility given to the final user. It gives the number of the last
% environment |{WithArrows}| at
% level~$0$ (to the sense of the nested environments). This macro is fully
% expandable and, thus, can be used directly in the name of a Tikz node.
%    \begin{macrocode}
\cs_new:Npn \WithArrowsLastEnv { \int_use:N \g_@@_last_env_int }
%    \end{macrocode}
%
% \bigskip
% \subsection{The command Arrow in CodeAfter}
%
% The option |CodeAfter| is an option of the environment |{WithArrows}| (this
% option is only available at the environment level). In the option |CodeAfter|,
% one can use the command |Arrow| but it's a special version of the command
% |Arrow|. For this special version (internally called |\@@_Arrow_code_after|),
% we define a special set of keys called |WithArrows/Arrow/CodeAfter|.
%
%    \begin{macrocode}
\keys_define:nn { WithArrows / Arrow / CodeAfter }
  {
    tikz     .code:n = 
      \tikzset { WithArrows / arrow / .append~style = { #1 } } ,
    tikz     .value_required:n  = true ,
    rr       .value_forbidden:n = true ,
    rr       .code:n            = \@@_fix_pos_option:n 0 ,
    ll       .value_forbidden:n = true,
    ll       .code:n            = \@@_fix_pos_option:n 1 ,
    rl       .value_forbidden:n = true ,
    rl       .code:n            = \@@_fix_pos_option:n 2 ,
    lr       .value_forbidden:n = true ,
    lr       .code:n            = \@@_fix_pos_option:n 3 ,
    v        .value_forbidden:n = true ,
    v        .code:n            = \@@_fix_pos_option:n 4 ,
    TikzCode .tl_set:N          = \l_@@_tikz_code_tl ,
    TikzCode .value_required:n  = true ,
    xoffset  .dim_set:N         = \l_@@_xoffset_dim ,
    xoffset  .value_required:n  = true ,
    unknown .code:n  = 
      \@@_sort_seq:N \l_@@_options_Arrow_CodeAfter_seq
      \@@_error:n { Unknown~option~Arrow~in~CodeAfter } 
 }
%    \end{macrocode}
%
% \bigskip
% A sequence of the options available in |\Arrow| in |\CodeAfter|. This sequence
% will be used in the error messages and can be modified dynamically.
%    \begin{macrocode}
\seq_set_from_clist:Nn \l_@@_options_Arrow_CodeAfter_seq
   { ll, lr, rl, rr, tikz, TikzCode, v, x, offset }
%    \end{macrocode}
% 
% \bigskip
%    \begin{macrocode}
\NewDocumentCommand \@@_Arrow_code_after { O { } m m m ! O { } }
  {
    \int_set:Nn \l_@@_pos_arrow_int 1
    \str_clear_new:N \l_@@_previous_key_str
    \group_begin:
      \keys_set:nn { WithArrows / Arrow / CodeAfter } 
        { #1, #5, tikz = { xshift = \l_@@_xoffset_dim } }
      \bool_set_false:N \l_@@_initial_r_bool
      \bool_set_false:N \l_@@_final_r_bool
      \int_case:nn \l_@@_pos_arrow_int
        { 0
            { 
              \bool_set_true:N \l_@@_initial_r_bool
              \bool_set_true:N \l_@@_final_r_bool
            }
          2 { \bool_set_true:N \l_@@_initial_r_bool }
          3 { \bool_set_true:N \l_@@_final_r_bool } 
        }
%    \end{macrocode}
% We prevent drawing a arrow from a line to itself.
%    \begin{macrocode}
      \tl_if_eq:nnTF { #2 } { #3 }
        { \@@_error:nn { Both~lines~are~equal } { #2 } }
%    \end{macrocode}
% We test wether the two Tikz nodes |(#2-l)| and |(#3-l)| really exist. If not,
% the arrow won't be drawn.
%    \begin{macrocode}
        {
          \cs_if_free:cTF { pgf@sh@ns@wa - \l_@@_prefix_str - #2 - l }
            { \@@_error:nx { Wrong~line~in~Arrow } { #2 } }
            { 
              \cs_if_free:cTF { pgf@sh@ns@wa - \l_@@_prefix_str - #3 - l }
                { \@@_error:nx { Wrong~line~in~Arrow } { #3 }  }
                { 
                  \int_compare:nNnTF \l_@@_pos_arrow_int = 4
                    {
                      \begin { tikzpicture } [ @@_standard ]
                        \tikz@scan@one@point \pgfutil@firstofone (#2-l.south)
                        \dim_set_eq:NN \l_tmpa_dim \pgf@x
                        \dim_set_eq:NN \l_tmpb_dim \pgf@y
                        \tikz@scan@one@point \pgfutil@firstofone (#3-l.north)
                        \dim_set:Nn \l_tmpa_dim 
                          { \dim_max:nn \l_tmpa_dim \pgf@x }
                        \tl_gset:Nx \g_tmpa_tl 
                          { \dim_use:N \l_tmpa_dim , \dim_use:N \l_tmpb_dim } 
                        \tl_gset:Nx \g_tmpb_tl 
                          { \dim_use:N \l_tmpa_dim , \dim_use:N \pgf@y } 
                      \end { tikzpicture } 
                    }
                    { 
                      \begin { tikzpicture } [ @@_standard ]
                        \tikz@scan@one@point \pgfutil@firstofone
                           ( #2-\bool_if:NTF\l_@@_initial_r_bool rl .south )
                        \tl_gset:Nx \g_tmpa_tl 
                           { \dim_use:N \pgf@x , \dim_use:N \pgf@y }
                        \tikz@scan@one@point \pgfutil@firstofone
                           ( #3-\bool_if:NTF\l_@@_final_r_bool rl .north )
                        \tl_gset:Nx \g_tmpb_tl 
                           { \dim_use:N \pgf@x , \dim_use:N \pgf@y }
                      \end { tikzpicture } 
                    }
                  \@@_draw_arrow:nnn \g_tmpa_tl \g_tmpb_tl { #4 } 
                } 
            }
        }
    \group_end:
  }
%    \end{macrocode}
%
%                               
% \bigskip
% \subsection{MultiArrow}
% The command |\@@_MultiArrow:nn| will be linked to |\MultiArrow| when the
% |CodeAfter| is executed.
%    
%    \begin{macrocode}
\cs_new_protected:Nn \@@_MultiArrow:nn
  {  
%    \end{macrocode}
% The user of the command |\MultiArrow| (in |CodeAfter|) will be able to specify
% the list of lines with the same syntax as the loop |\foreach| of \pkg{pgffor}.
% That's why we construct a ``clist'' of \pkg{expl3} from the specification of
% list given by the user. The construction of the ``clist'' must be global in
% order to exit the |\foreach| and that's why we construct the list in
% |\g_tmpa_clist|.
%    \begin{macrocode}
    \foreach \x in { #1 } 
      { 
        \cs_if_free:cTF { pgf@sh@ns@wa - \l_@@_prefix_str - \x - l }
           { \@@_error:nx { Wrong~line~specification~in~MultiArrow } \x }
           { \clist_gput_right:Nx \g_tmpa_clist \x } 
      } 
%    \end{macrocode}
% We sort the list |\g_tmpa_clist| because we want to extract the minimum and
% the maximum.
%    \begin{macrocode}
    \int_compare:nTF { \clist_count:N \g_tmpa_clist < 2 }
       { \@@_error:n { Too~small~specification~for~MultiArrow } }
       {
         \clist_sort:Nn \g_tmpa_clist 
           {
             \int_compare:nTF { ##1 > ##2 }
               \sort_return_swapped: 
               \sort_return_same:
           }
%    \end{macrocode}
% We extract the minimum in |\l_tmpa_tl| (it must be an integer but we store it
% in a token list of \pkg{expl3}).
%    \begin{macrocode}
         \clist_pop:NN \g_tmpa_clist \l_tmpa_tl
%    \end{macrocode}
%
% We extract the maximum in |\l_tmpb_tl|. The remaining list (in
% |\g_tmpa_clist|) will be sorted in decreasing order but never mind...
%    \begin{macrocode}
         \clist_reverse:N \g_tmpa_clist
         \clist_pop:NN \g_tmpa_clist \l_tmpb_tl
%    \end{macrocode}
%
% We draw the teeth of the rak (except the first one and the last one) with the
% auxiliary function |\@@_MultiArrow_i:n|. This auxiliary fonction is necessary
% to expand the specification of the list in the |\foreach| loop. The first and
% the last teeth of the rak can't be drawn the same way as the others (think,
% for example, to the case of the option ``|rounded corners|'' is used).
%    \begin{macrocode}
         \exp_args:NV \@@_MultiArrow_i:n \g_tmpa_clist
%    \end{macrocode}
%
% Now, we draw the rest of the structure.
%    \begin{macrocode}
         \begin { tikzpicture }
           [ 
             @@_standard , 
             every~path /.style = { WithArrows / arrow } 
           ] 
           \draw [<->] ([xshift = \l_@@_xoffset_dim]\l_tmpa_tl-r.south)
                       -- ++(5mm,0)
                       -- node (@@_label) {} 
                          ([xshift = \l_@@_xoffset_dim+5mm]\l_tmpb_tl-r.south)
                       -- ([xshift = \l_@@_xoffset_dim]\l_tmpb_tl-r.south)  ;
           \tikz@parse@node \pgfutil@firstofone (@@_label.west)
           \dim_set:Nn \l_tmpa_dim { 20 cm }
           \path \pgfextra { \tl_gset:Nx \g_tmpa_tl \tikz@text@width } ;
           \tl_if_empty:NF \g_tmpa_tl { \dim_set:Nn \l_tmpa_dim \g_tmpa_tl }
           \bool_if:nT { \l_@@_wrap_lines_bool && \l_@@_in_DispWithArrows_bool }
             { 
               \dim_set:Nn \l_tmpb_dim 
                  { \g_@@_right_x_dim - \pgf@x - 0.3333 em }
               \dim_compare:nNnT \l_tmpb_dim < \l_tmpa_dim
                 { \dim_set_eq:NN \l_tmpa_dim \l_tmpb_dim } 
             }
           \path (@@_label.west) 
            node [ anchor = west, text~width = \dim_use:N \l_tmpa_dim ] { #2 } ;
         \end{tikzpicture} 
      } 
 }
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_new_protected:Nn \@@_MultiArrow_i:n
  { 
    \begin {tikzpicture }
      [ 
        @@_standard , 
        every~path / .style = { WithArrows / arrow } 
      ] 
      \foreach \k in { #1 }
        { 
          \draw [ <- ] 
            ( [xshift = \l_@@_xoffset_dim]\k-r.south ) -- ++(5mm,0) ; 
        } ;
    \end { tikzpicture } 
  }
%    \end{macrocode}
%
%
% \bigskip
% \subsection{The error messages of the package}
%
%    \begin{macrocode}
\str_const:Nn \c_@@_option_ignored_str
  { If~you~go~on,~this~option~will~be~ignored. }
%    \end{macrocode}
% 
%    \begin{macrocode}
\@@_msg_new:nn { Value~for~a~key }
   {
     The~key~'\l_keys_key_tl'~should~be~used~without~value. \\
     However,~you~can~go~on~for~this~time.
   }
%    \end{macrocode}
%
%    \begin{macrocode}          
\@@_msg_new:nnn { Unknown~option~in~Arrow }
  { 
    The~option~'\l_keys_key_tl'~
    is~unknown~for~the~command~\l_@@_string_Arrow_for_msg_str\
    in~the~row~\int_use:N \g_@@_line_int\
    of~your~environment~\{\l_@@_type_env_str\}. \\
    \c_@@_option_ignored_str \\
    For~a~list~of~the~available~keys,~type~H~<return>.
  }
  { 
    The~available~keys~are~(in~alphabetic~order):~
    \seq_use:Nnnn \l_@@_options_Arrow_seq {~and~} {,~} {~and~}.
  }
%    \end{macrocode}
%
%
%    \begin{macrocode}          
\@@_msg_new:nnn { Unknown~option~WithArrows }
  {
    The~option~'\l_keys_key_tl'~is~unknown~in~\{\l_@@_type_env_str\}. \\
    \c_@@_option_ignored_str \\
    For~a~list~of~the~available~keys,~type~H~<return>.
  }
  {
    The~available~keys~are~(in~alphabetic~order):~
    \seq_use:Nnnn \l_@@_options_WithArrows_seq {~and~} {,~} {~and~}.
  }
%    \end{macrocode}
%
%    \begin{macrocode}          
\@@_msg_new:nnn { Unknown~option~DispWithArrows }
  { 
    The~option~'\l_keys_key_tl'~is~unknown~in~\{\l_@@_type_env_str\}. \\
    \c_@@_option_ignored_str \\
    For~a~list~of~the~available~keys,~type~H~<return>.
  }
  {
    The~available~keys~are~(in~alphabetic~order):~
    \seq_use:Nnnn \l_@@_options_DispWithArrows_seq {~and~} {,~} {~and~}.
  }
%    \end{macrocode}
%
%    \begin{macrocode}          
\@@_msg_new:nnn { Unknown~option~WithArrowsOptions }
  { 
    The~option~'\l_keys_key_tl'~is~unknown~in~
    \token_to_str:N \WithArrowsOptions. \\
    \c_@@_option_ignored_str \\
    For~a~list~of~the~available~keys,~type~H~<return>. 
  }
  {
    The~available~keys~are~(in~alphabetic~order):~
    \seq_use:Nnnn \l_@@_options_WithArrowsOptions_seq {~and~} {,~} {~and~}.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_msg_new:nnn { Unknown~option~Arrow~in~CodeAfter }
  { 
    The~option~'\l_keys_key_tl'~is~unknown~in~
    \token_to_str:N \Arrow\
    in~\token_to_str:N \CodeAfter. \\
    \c_@@_option_ignored_str \\
    For~a~list~of~the~available~keys,~type~H~<return>.
  }
  { 
    The~available~keys~are~(in~alphabetic~order):~
    \seq_use:Nnnn \l_@@_options_Arrow_CodeAfter_seq {~and~} {,~} {~and~}.
  }
%    \end{macrocode}
%
%
%    \begin{macrocode}          
\@@_msg_new:nn { Third~column~in~WithArrows }
 { 
   By~default,~an~environment~\{\l_@@_type_env_str\}~can~only~have~
   two~columns.~Maybe~you~have~forgotten~a~
   \c_backslash_str\c_backslash_str.~If~you~really~want~more~than~
   two~columns,~you~should~use~the~option~'more-columns'~at~a~global~
   level~or~for~an~environment. \\
   However,~you~can~go~one~for~this~time.
 }
%    \end{macrocode}
%
%    \begin{macrocode}          
\@@_msg_new:nn { Third~column~in~DispWithArrows }
  { 
    An~environment~\{\l_@@_type_env_str\}~can~only~have~two~columns.~
    Maybe~you~have~forgotten~a~\c_backslash_str\c_backslash_str\ 
    at~the~end~of~row~\int_use:N \g_@@_line_int. \\
    If~you~go~on,~you~may~have~other~errors.
  }
%    \end{macrocode}
%
%    \begin{macrocode}          
\@@_msg_new:nn { Negative~jump }
 { 
   You~can't~use~a~negative~value~for~the~option~'jump'~of~command~
   \l_@@_string_Arrow_for_msg_str\
   in~the~row~\int_use:N \g_@@_line_int\
   of~your~environment~\{\l_@@_type_env_str\}.~
   You~can~create~an~arrow~going~backwards~with~the~option~'<-'~of~Tikz. \\
   \c_@@_option_ignored_str
 }
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_msg_new:nn { new-group~without~groups }
  { 
    You~can't~use~the~option~'new-group'~for~the~command~
    \l_@@_string_Arrow_for_msg_str\
    because~you~are~not~in~'groups'~mode.~Try~to~use~the~option~
    'groups'~in~your~environment~\{\l_@@_type_env_str\}. \\
    \c_@@_option_ignored_str
  }
%    \end{macrocode}
%
%
%    \begin{macrocode}          
\@@_msg_new:nn          
 { Too~few~lines~for~an~arrow }
 { Line~\l_@@_input_line_str\
   :~an~arrow~specified~in~the~row~\int_use:N \l_@@_initial_int\
   of~your~environment~\{\l_@@_type_env_str\}~can't~be~drawn~
   because~it~arrives~after~the~last~row~of~the~environment. \\
   If~you~go~on,~this~arrow~will~be~ignored.
 }
%    \end{macrocode}
%
%    \begin{macrocode}          
\@@_msg_new:nn { WithArrows~outside~math~mode }
 { 
   The~environment~\{\l_@@_type_env_str\}~should~be~used~only~in~math~mode. \\
   Nevertheless,~you~can~go~on.
 }
%    \end{macrocode}
%
%    \begin{macrocode}          
\@@_msg_new:nn { DispWithArrows~in~math~mode }
  { 
    The~environment~\{\l_@@_type_env_str\}~should~be~used~only~
    outside~math~mode. \\
    If~you~go~on,~you~will~have~other~errors.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_msg_new:nn { Incompatible~options~in~Arrow }
  { 
    You~try~to~use~the~option~'\l_keys_key_tl'~but~
    this~option~is~incompatible~or~redundant~with~the~option~
    '\l_@@_previous_key_str'~set~in~the~same~command~
    \l_@@_string_Arrow_for_msg_str. \\
    \c_@@_option_ignored_str
  }
%    \end{macrocode}
% 
%
%    \begin{macrocode}          
\@@_msg_new:nn { Incompatible~options }
  { You~try~to~use~the~option~'\l_keys_key_tl'~but~
    this~option~is~incompatible~or~redundant~with~the~option~
    '\l_@@_previous_key_str'~set~in~the~same~command~
    \bool_if:NT \l_@@_in_CodeAfter_bool
      { 
        \l_@@_string_Arrow_for_msg_str\
        in~the~CodeAfter~of~your~environment~\{\l_@@_type_env_str\}
      }. \\
    \c_@@_option_ignored_str
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_msg_new:nn { Arrow~in~first~column }
  { 
    You~should~not~use~the~command~\l_@@_string_Arrow_for_msg_str\
    in~the~first~column~of~your~environment~\{\l_@@_type_env_str\}~
    but~only~in~the~second~column. \\
    However~you~can~go~on~for~this~time.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_msg_new:nn { Wrong~line~in~Arrow }
  { 
    The~specification~of~line~'#1'~you~use~in~the~command~
    \l_@@_string_Arrow_for_msg_str\
    in~the~'CodeAfter'~of~\{\l_@@_type_env_str\}~doesn't~exist. \\
    If~you~go~on,~this~command~will~be~ignored.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_msg_new:nn { Both~lines~are~equal }
  {
    In~the~'CodeAfter'~of~\{\l_@@_type_env_str\}~you~try~to~
    draw~an~arrow~going~to~it~self~from~the~line~'#1'.~This~is~not~possible. \\
    If~you~go~on,~this~command~will~be~ignored.
  }
%
%    \begin{macrocode}
\@@_msg_new:nn { Wrong~line~specification~in~MultiArrow }
  { 
    The~specification~of~line~'#1'~doesn't~exist. \\
    If~you~go~on,~it~will~be~ignored~for~\token_to_str:N \MultiArrow.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_msg_new:nn { Too~small~specification~for~MultiArrow }
  { 
    The~specification~of~lines~you~gave~to~\token_to_str:N \MultiArrow\ 
    is~too~small:~you~need~at~least~two~lines. \\
    If~you~go~on,~this~command~will~be~ignored.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_msg_new:nn { tag*~without~amsmath }
  { 
    We~can't~use~\token_to_str:N\tag*~because~you~haven't~loaded~amsmath~
    (or~mathtools). \\
    If~you~go~on,~the~command~\token_to_str:N\tag\ 
    will~be~used~instead.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_msg_new:nn { Not~allowed~in~DispWithArrows }
  { 
    The~command~\token_to_str:N #1
    is~not~allowed~in~the~first~column~of~\{\l_@@_type_env_str\}~but~
    only~in~the~second~column. \\
    If~you~go~on,~this~command~will~be~ignored.
  }
%    \end{macrocode}
% 
%    \begin{macrocode}
\@@_msg_new:nn { Not~allowed~in~WithArrows }
  { 
    The~command~\token_to_str:N #1 is~not~allowed~in~\{\l_@@_type_env_str\}~
    (it's~allowed~in~the~second~column~of~\{DispWithArrows\}). \\
    If~you~go~on,~this~command~will~be~ignored.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_msg_new:nn { Multiple~tags }
 {
   You~can't~use~twice~the~command~\token_to_str:N\tag\ 
   in~a~line~of~the~environment~\{\l_@@_type_env_str\}. \\
   If~you~go~on,~the~tag~'#1'~will~be~used.
 }
%    \end{macrocode}
%
%
%    \begin{macrocode}
\@@_msg_new:nn { Multiple~labels }
  { 
    Normally,~we~can't~use~the~command~\token_to_str:N\label\ 
    twice~in~a~line~of~the~environment~\{\l_@@_type_env_str\}. \\
    However,~you~can~go~on.~
    \bool_if:NT \c_@@_showlabels_loaded_bool
      { However,~only~the~last~label~will~be~shown~by~showlabels.~ }
    If~you~don't~want~to~see~this~message~again,~you~can~use~the~option~
    'allow-multiple-labels'~at~the~global~or~environment~level.
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\@@_msg_new:nn { Multiple~labels~with~cleveref }
  {
    Since~you~use~cleveref,~you~can't~use~the~command~\token_to_str:N\label\ 
    twice~in~a~line~of~the~environment~\{\l_@@_type_env_str\}. \\
    If~you~go~on,~you~may~have~undefined~references.
  }
%    \end{macrocode}
%
% 
%    \begin{macrocode}
\@@_msg_new:nn { Inexistent~v-node }
  {
    There~is~a~problem.~Maybe~you~have~put~a~command~\token_to_str:N\cr\
    instead~of~a~command~\token_to_str:N\\~at~the~end~of~
    the~row~\int_use:N \l_tmpa_int\
    of~your~environment~\{\l_@@_type_env_str\}. \\
    If~you~go~on,~you~may~have~an~incorrect~output.
  }
%    \end{macrocode}
%
%    \begin{macrocode}          
\@@_msg_new:nn { Option~xoffset~forbidden }
  { You~can't~use~the~option~'xoffset'~in~the~command~
    \l_@@_string_Arrow_for_msg_str\
    while~you~are~using~the~option~
    ' \int_compare:nNnTF \l_@@_pos_arrow_int = 7
         { group } 
         { groups } '. \\
    \c_@@_option_ignored_str
  }
%    \end{macrocode}
%
% 
%
% \subsection{The command WithArrowsNewStyle}
%
% A new key defined with |\WithArrowsNewStyle| will not be available at the
% local level.
%    \begin{macrocode}
\NewDocumentCommand \WithArrowsNewStyle { m m }
  { 
    \keys_if_exist:nnTF { WithArrows / WithArrows } { #1 }
      { \@@_error:nn { Key~already~defined } { #1 } }
      { 
        \keys_define:nn { WithArrows / WithArrows }
           { 
             #1 .code:n = 
                  { 
                    \keys_define:nn { WithArrows / WithArrows }
                       { unknown .code:n = \prg_do_nothing: }
                    \keys_set:nn { WithArrows / WithArrows } { #2 } 
                    \keys_define:nn { WithArrows / WithArrows }
                       { unknown .code:n = 
                          \@@_error:n { Unknown~option~WithArrows }} 
                  }
           } 
       \seq_put_right:Nn \l_@@_options_WithArrows_seq {#1}
       \keys_define:nn { WithArrows / DispWithArrows }
           { 
             #1 .code:n = 
                  { 
                    \keys_define:nn { WithArrows / DispWithArrows }
                       { unknown .code:n = \prg_do_nothing: }
                    \keys_set:nn { WithArrows / DispWithArrows } { #2 } 
                    \keys_define:nn {WithArrows / DispWithArrows }
                       { unknown .code:n = 
                           \@@_error:n { Unknown~option~DispWithArrows }} 
                  }
           } 
       \seq_put_right:Nn \l_@@_options_DispWithArrows_seq { #1 }
       \keys_define:nn { WithArrows / WithArrowsOptions }
           { 
             #1 .code:n = 
              { \keys_set:nn { WithArrows / WithArrowsOptions } { #2 } } 
           }
       \seq_put_right:Nn \l_@@_options_WithArrowsOptions_seq { #1 }
%    \end{macrocode}
% We now set the options in a TeX group in order to detect if some keys in |#2|
% are unknown. If a key is unknown, an error will be raised. However, the key
% will, even so, be stored in the definition of key~|#1|. When the key~|#1| will
% be used, the error will be raised again.
%    \begin{macrocode}
       \group_begin:
           \msg_set:nnn { witharrows } { Unknown~option~WithArrowsOptions }
              {
                The~option~'\l_keys_key_tl'~can't~be~set~in~the~
                definition~of~a~style. \\
                If~you~go~on,~this~key~will~not~be~written~in~the~style~'#1'.
              }
           \WithArrowsOptions { #2 }
       \group_end:
      } 
  }
%    \end{macrocode}
% 
%    \begin{macrocode}
\@@_msg_new:nn { Key~already~defined }
  {
    The~key~'#1'~is~already~defined. \\
    If~you~go~on,~your~instruction~\token_to_str:N\WithArrowsNewStyle\ 
    will~be~ignored.
  }
%    \end{macrocode}
%
%
% \subsection{The options up and down}
%
% The options |up| and |down| are available for individual arrows. The
% corresponding code is given here. It is independent of the main code of the
% extension \pkg{witharrows}.
% 
% This code is the only part of the code of \pkg{witharrows} which uses the
% package \pkg{varwidth} and also the Tikz library |calc|. That's why we have
% decided not to load this package and this library. If they are not loaded, the
% user will have an error only if he uses the option |up| or the option |down|.
% 
% \medskip
% The token list |\c_@@_tikz_code_up_tl| is the value of |TikzCode| which will
% be used for an option |up|.
%    \begin{macrocode}
\tl_const:Nn \c_@@_tikz_code_up_tl
  {
    \draw [ rounded~corners ]
       let \p1 = (#1) ,
           \p2 = (#2)
       in (\p1) -- node { 
                          \dim_set:Nn \l_tmpa_dim { \x2 - \x1 }
                          \begin { varwidth } \l_tmpa_dim
                            \raggedright
                            #3
                          \end { varwidth } 
                        } 
          (\x2,\y1) -- (\p2) ;
  }
%    \end{macrocode}
% 
% \medskip
% Idem for the option |down|.
%    \begin{macrocode}
\tl_const:Nn \c_@@_tikz_code_down_tl
  {
     \draw [ rounded~corners ]
       let \p1 = (#1) ,
           \p2 = (#2)
       in (\p1) -- (\x1,\y2) --
                node {
                       \dim_set:Nn \l_tmpa_dim { \x1 - \x2 }
                       \begin { varwidth } \l_tmpa_dim
                         \raggedright
                         #3
                       \end { varwidth }
                     } 
                (\p2) ;
  }
%    \end{macrocode}
% 
%    \begin{macrocode}
\keys_define:nn { WithArrows / Arrow / FirstPass }
  {
    up   .code:n = \@@_set_independent: ,
    down .code:n = \@@_set_independent: ,
    up   .default:n = NoValue ,
    down .default:n = NoValue 
  }
%    \end{macrocode}
% 
% \bigskip
%    \begin{macrocode}
\keys_define:nn { WithArrows / Arrow / SecondPass }
 { 
   up .code:n =  \str_if_empty:NT \l_@@_previous_key_str
                   { 
                     \str_set:Nn \l_@@_previous_key_str { up }
                     \bool_if:NTF \c_@@_varwidth_loaded_bool
                       { 
                         \cs_if_exist:cTF { tikz@library@calc@loaded }
                           { 
                             \int_set:Nn \l_@@_pos_arrow_int \c_one_int
%    \end{macrocode}
% We have to set |\l_@@_wrap_lines_bool| to |false| because, otherwise, if the
% option |wrap_lines| is used at a higher level (global or environment), we will
% have a special affectation to |TikzCode| that will overwrite our affectation.
%    \begin{macrocode}
                             \bool_set_false:N \l_@@_wrap_lines_bool
                             \tl_set_eq:NN \l_@@_tikz_code_tl 
                               \c_@@_tikz_code_up_tl
                           }
                           { \@@_error:n { calc~not~loaded } }
                       }
                       { \@@_error:n { varwidth~not~loaded } } 
                   } ,
   down .code:n = \str_if_empty:NT \l_@@_previous_key_str
                    { 
                      \str_set:Nn \l_@@_previous_key_str { down }
                      \bool_if:NTF \c_@@_varwidth_loaded_bool
                        { 
                          \cs_if_exist:cTF { tikz@library@calc@loaded }
                            { 
                              \int_set:Nn \l_@@_pos_arrow_int \c_one_int
                              \bool_set_false:N \l_@@_wrap_lines_bool
                              \tl_set_eq:NN \l_@@_tikz_code_tl 
                                \c_@@_tikz_code_down_tl
                            }
                            { \@@_error:n { calc~not~loaded } }
                        }
                        { \@@_error:n { varwidth~not~loaded } } 
                    }
 }
%    \end{macrocode}
% 
%    \begin{macrocode}
\seq_put_right:Nn \l_@@_options_Arrow_seq { down }
\seq_put_right:Nn \l_@@_options_Arrow_seq { up }
%    \end{macrocode}
%
%
%    \begin{macrocode}
\@@_msg_new:nn { varwidth~not~loaded } 
  {
    You~can't~use~the~option~'\l_keys_key_tl'~because~
    you~don't~have~loaded~the~package~'varwidth'. \\
    \c_@@_option_ignored_str
  }
%    \end{macrocode}
% 
%    \begin{macrocode}
\@@_msg_new:nn { calc~not~loaded }
  { 
    You~can't~use~the~option~'\l_keys_key_tl'~because~you~don't~have~loaded~the~
    Tikz~library~'calc'.You~should~add~'\token_to_str:N\usetikzlibrary{calc}'
    ~in~your~preamble. \\
    \c_@@_option_ignored_str
  }
%    \end{macrocode}
% 
% \section{History}
%
% \subsection*{Changes between versions 1.0 and 1.1}
% 
% Option for the command |\\| and option |interline|
% 
% Compatibility with |\usetikzlibrary{babel}|
%
% Possibility of nested environments |{WithArrows}|
% 
%
% \subsection*{Changes between versions 1.1 and 1.2}
%
% The package \pkg{witharrows} can now be loaded without having loaded
% previously \pkg{tikz} and the libraries |arrow.meta| and |bending| (this
% extension and these libraries are loaded silently by \pkg{witharrows}).
%
% New option |groups| (with a \emph{s})
%
% Better error messages
% 
% \subsection*{Changes between versions 1.2 and 1.3}
% 
% New options |ygap| and |ystart| for fine tuning.
%
% \subsection*{Changes between versions 1.3 and 1.4}
% 
% The package \pkg{footnote} is no longer loaded by default. Instead, two
% options |footnote| and |footnotehyper| have been added. In particular,
% \pkg{witharrows} becomes compatible with \cls{beamer}.
% 
% \subsection*{Changes between versions 1.4 and 1.5}
% 
% The Tikz code used to draw the arrows can be changed with the option
% |TikzCode|.
%
% Two new options |CodeBefore| and |CodeAfter| have been added at the
% environment level.
%
% A special version of |\Arrow| is available in |CodeAfter| in order to draw
% arrows in nested environments.
% 
% A command |\MultiArrow| is available in |CodeAfter| to draw arrows of other
% shapes.
% 
% \subsection*{Changes between versions 1.5 and 1.6}
% 
% The code has been improved to be faster and the Tikz library |calc| is no
% longer required.
%
% A new option |name| is available for the environments |{WithArrows}|.
%
% In the version 1.6.1, correction of a bug that leads to incompatibility with
% |\usetikzlibrary{babel}|.
%
% \subsection*{Changes between 1.6.1 and 1.7}
%
% New environments |{DispWithArrows}| and |{DispWithArrows*}|.
%
% \subsection*{Changes between 1.7 and 1.8}
%
% The numbers and tags of the environment |{DispWithArrows}| are now compatible
% with all the major LaTeX packages concerning references (\pkg{autonum},
% \pkg{cleveref}, \pkg{fancyref}, \pkg{hyperref}, \pkg{prettyref},
% \pkg{refstyle}, \pkg{typedref} and \pkg{varioref}) and with the options
% |showonlyrefs| and |showmanualtags| of \pkg{mathtools}.
%
% \subsection*{Changes between 1.8 and 1.9}
% 
% New option |wrap-lines| for the environments |{DispWithArrows}| and
% |{DispWithArrows*}|.
%
% \subsection*{Changes between 1.9 and 1.10}
%
% If the option |wrap-lines| is used, the option ``|text width|'' of Tikz is
% still active: if the value given to ``|text width|'' is lower than the width
% computed by |wrap-lines|, this value is used to wrap the lines.
%
% The option |wrap-lines| is now fully compatible with the class option |leqno|.
%
% Correction of a bug: |\nointerlineskip| and |\makebox[.6\linewidth]{}| should
% be inserted in |{DispWithArrows}| only in vertical mode.
%
% \subsection*{Changes between 1.10 and 1.11}
%
% New commands |\WithArrowsNewStyle| and |\WithArrowsRightX|.
%
% \subsection*{Changes between 1.11 and 1.12}
%
% New command |\tagnextline|.
%
% New option |tagged-lines|.
%
% An option of position (|ll|, |lr|, |rl|, |rr| or |i|) is now allowed at the
% local level even if the option |group| or the option |groups| is used at the
% global or environment level.
%
% Compatibility of |{DispWithArrows}| with |\qedhere| of \pkg{amsthm}.
%
% Compatibility with the packages \pkg{refcheck}, \pkg{showlabels} and
% \pkg{listlbls}.
%
% The option |\AllowLineWithoutAmpersand| is deprecated because lines without
% ampersands are now always allowed.
%
% \subsection*{Changes between 1.12 and 1.13}
%
% Options |start-adjust|, |end-adjust| and |adjust|.
% 
% This version is not stricty compatible with previous ones. To restore the
% behaviour of the previous versions, one has to use the option |adjust| with
% the value $0$~pt:
% 
% \begin{Verbatim}
% \WithArrowsOptions{adjust = 0pt}
% \end{Verbatim}
%
% \subsection*{Changes between 1.13 et 1.14}
%
% New options |up| and |down| for the arrows.
%
% \smallskip
% Replacement of some options |O { }| in commands and environments defined with
% \pkg{xparse} by |! O { }| (because a recent version of \pkg{xparse} introduced
% the specifier |!| and modified the default behaviour of the last optional
% arguments:
% |//www.texdev.net/2018/04/21/xparse-optional-arguments-at-the-end|).
%
% \smallskip
% Modification of the code of |\WithArrowsNewStyle| following a correction of a
% bug in \pkg{l3keys} in the version of \pkg{l3kernel} of 2019/01/28.
% 
% New error message |Inexistent~v-node| to avoid a \pkg{pgf} error.
%
% The error |Option incompatible with 'group(s)'| was suppressed in the version
% 1.12 but this was a mistake since this error is used with the option |xoffset|
% at the local level. The error is put back.
% 
% \subsection*{Changes between 1.14 et 1.15}
%
% Option |new-group| to start a new group of arrows (only available when the
% environment is composed with the option the option |groups|).
%
% Tikz externalization is now deactivated in the environments of the
% extension \pkg{witharrows}.\footnote{Before this version, there was an error
% when using \pkg{witharrows} with Tikz externalization. In any case, it's not
% possible to externalize the Tikz elements constructed by \pkg{witharrows}
% because they use the options |overlay| and |remember picture|.} 
%
% \endinput
% Local Variables:
% TeX-fold-mode: nil
% fill-column: 80
% End:
